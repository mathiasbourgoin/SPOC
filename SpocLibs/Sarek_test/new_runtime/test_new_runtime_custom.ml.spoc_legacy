(******************************************************************************
 * E2E test for Sarek NewRuntime with custom types
 *
 * This test verifies that:
 * 1. Custom types (SPOC Vector) work with the new ctypes plugin runtime
 * 2. The alloc_custom and ptr transfer functions work correctly
 * 3. A kernel operating on custom types produces correct results
 ******************************************************************************)

open Spoc
module Std = Sarek_stdlib.Std

(* Force plugin initialization *)
let () = Sarek_cuda.Cuda_plugin.init ()

let () = Sarek_opencl.Opencl_plugin.init ()

type float32 = float

(* Custom record type for 2D points - PPX generates point_custom for Vector.Custom *)
type point = {mutable x : float32; mutable y : float32} [@@sarek.type]

let size = 1024

let () =
  print_endline "=== NewRuntime Custom Types Test ===" ;

  (* Step 1: Initialize SPOC devices (needed for code generation) *)
  print_endline "\n[1] Initializing SPOC devices for code generation..." ;
  let spoc_devs = Devices.init () in
  if Array.length spoc_devs = 0 then begin
    print_endline "No SPOC devices found - cannot generate code" ;
    exit 1
  end ;
  let spoc_dev = spoc_devs.(0) in
  Printf.printf
    "SPOC device for codegen: %s\n"
    spoc_dev.Devices.general_info.name ;

  (* Step 2: Initialize new runtime devices *)
  print_endline "\n[2] Initializing new runtime devices..." ;
  let new_devs = Sarek_core.Device.init ~frameworks:["CUDA"; "OpenCL"] () in
  if Array.length new_devs = 0 then begin
    print_endline "No new runtime devices found - skipping test" ;
    print_endline "=== Test SKIPPED ===" ;
    exit 0
  end ;
  let new_dev =
    match Sarek_core.Device.best () with
    | Some d -> d
    | None -> failwith "No device available"
  in
  Printf.printf "New runtime device: %s (%s)\n" new_dev.name new_dev.framework ;

  (* Step 3: Define a Sarek kernel for transforming points *)
  print_endline "\n[3] Defining Sarek kernel for custom types..." ;
  let transform_points =
    [%kernel
      fun (src : point vector) (dst : point vector) (n : int) ->
        let open Std in
        let tid = global_thread_id in
        if tid < n then begin
          let p = src.(tid) in
          (* Copy p to dst, then update fields in-place.
             This avoids the anonymous record issue with record literals. *)
          dst.(tid) <- p ;
          dst.(tid).x <- p.x +. 1.0 ;
          dst.(tid).y <- p.y *. 2.0
        end]
  in
  print_endline "Kernel defined successfully" ;

  (* Step 4: Generate source code from the kernel IR *)
  print_endline "\n[4] Generating source code from IR..." ;
  let source =
    Sarek.Kirc.NewRuntime.generate_source
      transform_points
      ~framework:new_dev.framework
      spoc_dev
  in
  Printf.printf
    "Generated %d bytes of %s source\n"
    (String.length source)
    new_dev.framework ;

  (* Show first few lines of generated code *)
  let lines = String.split_on_char '\n' source in
  print_endline "First 15 lines of generated code:" ;
  List.iteri (fun i line -> if i < 15 then Printf.printf "  %s\n" line) lines ;

  (* Step 5: Create host vectors using SPOC Vector *)
  print_endline "\n[5] Creating host vectors..." ;
  let src_vec = Vector.create (Vector.Custom point_custom) size in
  let dst_vec = Vector.create (Vector.Custom point_custom) size in

  (* Initialize source points *)
  for i = 0 to size - 1 do
    Mem.set src_vec i {x = float_of_int i; y = float_of_int (i * 2)}
  done ;
  print_endline "Host vectors created and initialized" ;

  (* Step 6: Allocate device buffers using new runtime *)
  print_endline "\n[6] Allocating device buffers..." ;
  let elem_size = point_custom.size in
  Printf.printf "Element size: %d bytes\n" elem_size ;
  let buf_src = Sarek_core.Runtime.alloc_custom new_dev ~size ~elem_size in
  let buf_dst = Sarek_core.Runtime.alloc_custom new_dev ~size ~elem_size in
  print_endline "Device buffers allocated" ;

  (* Step 7: Transfer source data to device *)
  print_endline "\n[7] Transferring data to device..." ;

  (* Get raw pointer from SPOC Vector's customarray *)
  let src_data =
    match Vector.vector src_vec with
    | Vector.CustomArray (arr, _) -> arr
    | _ -> failwith "Expected CustomArray"
  in
  let dst_data =
    match Vector.vector dst_vec with
    | Vector.CustomArray (arr, _) -> arr
    | _ -> failwith "Expected CustomArray"
  in

  (* Get raw pointers using Spoc's customarray_ptr *)
  let src_ptr =
    Ctypes.(to_voidp (ptr_of_raw_address (Vector.customarray_ptr src_data)))
  in
  Sarek_core.Runtime.to_device_ptr ~src_ptr ~dst:buf_src ;
  print_endline "Data transferred to device" ;

  (* Step 8: Execute kernel *)
  print_endline "\n[8] Executing kernel via new runtime..." ;
  let block = Sarek_core.Runtime.dims1d 256 in
  let grid = Sarek_core.Runtime.dims1d ((size + 255) / 256) in

  Sarek_core.Runtime.run
    new_dev
    ~name:"spoc_dummy"
    ~source
    ~args:
      [
        Sarek_core.Runtime.ArgBuffer buf_src;
        Sarek_core.Runtime.ArgInt32 (Int32.of_int size);
        Sarek_core.Runtime.ArgBuffer buf_dst;
        Sarek_core.Runtime.ArgInt32 (Int32.of_int size);
        Sarek_core.Runtime.ArgInt32 (Int32.of_int size);
      ]
    ~grid
    ~block
    () ;
  print_endline "Kernel executed" ;

  (* Step 9: Transfer results back *)
  print_endline "\n[9] Transferring results back..." ;
  let dst_ptr =
    Ctypes.(to_voidp (ptr_of_raw_address (Vector.customarray_ptr dst_data)))
  in
  Sarek_core.Runtime.from_device_ptr ~src:buf_dst ~dst_ptr ;
  print_endline "Results transferred back" ;

  (* Step 10: Verify results *)
  print_endline "\n[10] Verifying results..." ;
  let errors = ref 0 in
  for i = 0 to size - 1 do
    let expected_x = float_of_int i +. 1.0 in
    let expected_y = float_of_int (i * 2) *. 2.0 in
    let result = Mem.get dst_vec i in
    if
      abs_float (result.x -. expected_x) > 1e-3
      || abs_float (result.y -. expected_y) > 1e-3
    then begin
      if !errors < 5 then
        Printf.printf
          "  Error at %d: expected {x=%.1f; y=%.1f}, got {x=%.1f; y=%.1f}\n"
          i
          expected_x
          expected_y
          result.x
          result.y ;
      incr errors
    end
  done ;

  if !errors > 0 then begin
    Printf.printf "Total errors: %d\n" !errors ;
    print_endline "=== Test FAILED ===" ;
    exit 1
  end ;

  (* Cleanup *)
  Sarek_core.Runtime.free buf_src ;
  Sarek_core.Runtime.free buf_dst ;

  print_endline "All results verified correctly!" ;
  print_endline "\n=== Test PASSED ==="
