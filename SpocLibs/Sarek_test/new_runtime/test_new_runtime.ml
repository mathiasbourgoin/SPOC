(******************************************************************************
 * E2E test for Sarek NewRuntime integration
 *
 * This test verifies that:
 * 1. Kirc.NewRuntime.generate_source generates valid GPU code from kernel IR
 * 2. The generated code can be executed via the new ctypes plugin runtime
 ******************************************************************************)

open Spoc

(* Force plugin initialization *)
let () = Sarek_cuda.Cuda_plugin.init ()

let () = Sarek_opencl.Opencl_plugin.init ()

let size = 1024

let () =
  print_endline "=== NewRuntime Integration Test ===" ;

  (* Step 1: Initialize SPOC devices (needed for code generation) *)
  print_endline "\n[1] Initializing SPOC devices for code generation..." ;
  let spoc_devs = Devices.init () in
  if Array.length spoc_devs = 0 then begin
    print_endline "No SPOC devices found - cannot generate code" ;
    exit 1
  end ;
  let spoc_dev = spoc_devs.(0) in
  Printf.printf
    "SPOC device for codegen: %s\n"
    spoc_dev.Devices.general_info.name ;

  (* Step 2: Initialize new runtime devices *)
  print_endline "\n[2] Initializing new runtime devices..." ;
  let new_devs = Sarek_core.Device.init ~frameworks:["CUDA"; "OpenCL"] () in
  if Array.length new_devs = 0 then begin
    print_endline "No new runtime devices found - skipping test" ;
    print_endline "=== Test SKIPPED ===" ;
    exit 0
  end ;
  let new_dev =
    match Sarek_core.Device.best () with
    | Some d -> d
    | None -> failwith "No device available"
  in
  Printf.printf "New runtime device: %s (%s)\n" new_dev.name new_dev.framework ;

  (* Step 3: Define a Sarek kernel *)
  print_endline "\n[3] Defining Sarek kernel..." ;
  let vector_add =
    [%kernel
      fun (a : float32 vector)
          (b : float32 vector)
          (c : float32 vector)
          (n : int) ->
        let open Std in
        let tid = global_thread_id in
        if tid < n then c.(tid) <- a.(tid) +. b.(tid)]
  in
  print_endline "Kernel defined successfully" ;

  (* Step 4: Generate source code from the kernel IR *)
  print_endline "\n[4] Generating source code from IR..." ;
  let source =
    Sarek.Kirc.NewRuntime.generate_source
      vector_add
      ~framework:new_dev.framework
      spoc_dev
  in
  Printf.printf
    "Generated %d bytes of %s source\n"
    (String.length source)
    new_dev.framework ;

  (* Show first few lines of generated code *)
  let lines = String.split_on_char '\n' source in
  print_endline "First 10 lines of generated code:" ;
  List.iteri (fun i line -> if i < 10 then Printf.printf "  %s\n" line) lines ;

  (* Step 5: Allocate buffers in new runtime *)
  print_endline "\n[5] Allocating buffers..." ;
  let buf_a = Sarek_core.Runtime.alloc_float32 new_dev size in
  let buf_b = Sarek_core.Runtime.alloc_float32 new_dev size in
  let buf_c = Sarek_core.Runtime.alloc_float32 new_dev size in
  print_endline "Buffers allocated" ;

  (* Step 6: Initialize host data and transfer *)
  print_endline "\n[6] Initializing data and transferring to device..." ;
  let host_a = Bigarray.Array1.create Bigarray.float32 Bigarray.c_layout size in
  let host_b = Bigarray.Array1.create Bigarray.float32 Bigarray.c_layout size in
  let host_c = Bigarray.Array1.create Bigarray.float32 Bigarray.c_layout size in
  for i = 0 to size - 1 do
    Bigarray.Array1.set host_a i (float_of_int i) ;
    Bigarray.Array1.set host_b i (float_of_int (i * 2)) ;
    Bigarray.Array1.set host_c i 0.0
  done ;
  Sarek_core.Runtime.to_device ~src:host_a ~dst:buf_a ;
  Sarek_core.Runtime.to_device ~src:host_b ~dst:buf_b ;
  Sarek_core.Runtime.to_device ~src:host_c ~dst:buf_c ;
  print_endline "Data transferred to device" ;

  (* Step 7: Execute kernel using new runtime *)
  print_endline "\n[7] Executing kernel via new runtime..." ;
  let block = Sarek_core.Runtime.dims1d 256 in
  let grid = Sarek_core.Runtime.dims1d ((size + 255) / 256) in

  (* The kernel name is "spoc_dummy" as generated by Sarek *)
  Sarek_core.Runtime.run
    new_dev
    ~name:"spoc_dummy"
    ~source
    ~args:
      [
        Sarek_core.Runtime.ArgBuffer buf_a;
        Sarek_core.Runtime.ArgInt32 (Int32.of_int size);
        (* Vector length *)
        Sarek_core.Runtime.ArgBuffer buf_b;
        Sarek_core.Runtime.ArgInt32 (Int32.of_int size);
        (* Vector length *)
        Sarek_core.Runtime.ArgBuffer buf_c;
        Sarek_core.Runtime.ArgInt32 (Int32.of_int size);
        (* Vector length *)
        Sarek_core.Runtime.ArgInt32 (Int32.of_int size);
        (* n parameter *)
      ]
    ~grid
    ~block
    () ;
  print_endline "Kernel executed" ;

  (* Step 8: Transfer back and verify *)
  print_endline "\n[8] Verifying results..." ;
  Sarek_core.Runtime.from_device ~src:buf_c ~dst:host_c ;

  let errors = ref 0 in
  for i = 0 to size - 1 do
    let expected = float_of_int i +. float_of_int (i * 2) in
    let got = Bigarray.Array1.get host_c i in
    if abs_float (got -. expected) > 0.001 then begin
      if !errors < 5 then
        Printf.printf
          "  Mismatch at %d: expected %.2f, got %.2f\n"
          i
          expected
          got ;
      incr errors
    end
  done ;

  if !errors > 0 then begin
    Printf.printf "Total errors: %d\n" !errors ;
    print_endline "=== Test FAILED ===" ;
    exit 1
  end ;

  (* Cleanup *)
  Sarek_core.Runtime.free buf_a ;
  Sarek_core.Runtime.free buf_b ;
  Sarek_core.Runtime.free buf_c ;

  print_endline "All results verified correctly!" ;
  print_endline "\n=== Test PASSED ==="
