(******************************************************************************
 * E2E test for Runtime V2 with Sarek PPX
 *
 * Tests that Sarek PPX kernels work correctly on ALL devices (CUDA, OpenCL,
 * Native) using the standard SPOC API. This validates that the V2 runtime
 * infrastructure integrates properly with the existing execution path.
 ******************************************************************************)

open Spoc
module Std = Sarek_stdlib.Std

let size = 1024

(* Define kernel using Sarek PPX - pure OCaml, works on all devices *)
let vector_add =
  [%kernel
    fun (a : float32 vector)
        (b : float32 vector)
        (c : float32 vector)
        (n : int) ->
      let open Std in
      let tid = global_thread_id in
      if tid < n then c.(tid) <- a.(tid) +. b.(tid)]

(* Run kernel on a single device and return (time_ms, ok) *)
let run_on_device dev =
  (* Create vectors *)
  let a = Vector.create Vector.float32 size in
  let b = Vector.create Vector.float32 size in
  let c = Vector.create Vector.float32 size in

  (* Initialize *)
  for i = 0 to size - 1 do
    Mem.set a i (float_of_int i) ;
    Mem.set b i (float_of_int (i * 2)) ;
    Mem.set c i 0.0
  done ;

  (* Generate kernel for this device *)
  ignore (Sarek.Kirc.gen vector_add dev) ;

  (* Setup grid/block *)
  let block_size =
    match dev.Devices.specific_info with
    | Devices.OpenCLInfo clI -> (
        match clI.Devices.device_type with
        | Devices.CL_DEVICE_TYPE_CPU -> 1
        | _ -> 256)
    | _ -> 256
  in
  let grid_size = (size + block_size - 1) / block_size in
  let block =
    {Kernel.blockX = block_size; Kernel.blockY = 1; Kernel.blockZ = 1}
  in
  let grid = {Kernel.gridX = grid_size; Kernel.gridY = 1; Kernel.gridZ = 1} in

  (* Run kernel *)
  let t0 = Unix.gettimeofday () in
  Sarek.Kirc.run vector_add (a, b, c, size) (block, grid) 0 dev ;
  Devices.flush dev () ;
  let t1 = Unix.gettimeofday () in
  let time_ms = (t1 -. t0) *. 1000.0 in

  (* Verify results *)
  Mem.to_cpu c () ;
  Devices.flush dev () ;
  let errors = ref 0 in
  for i = 0 to size - 1 do
    let expected = float_of_int i +. float_of_int (i * 2) in
    let got = Mem.get c i in
    if abs_float (got -. expected) > 0.001 then begin
      if !errors < 5 then
        Printf.printf
          "  Mismatch at %d: expected %.2f, got %.2f\n"
          i
          expected
          got ;
      incr errors
    end
  done ;
  (time_ms, !errors = 0)

let () =
  print_endline "=== Runtime V2 Vector Add Test ===" ;
  print_endline "Testing Sarek PPX kernel on ALL available devices\n" ;

  (* Initialize SPOC with native CPU backend *)
  let devs = Devices.init ~native:true () in
  if Array.length devs = 0 then begin
    print_endline "No devices found" ;
    exit 1
  end ;

  Printf.printf "Found %d device(s):\n" (Array.length devs) ;
  Array.iteri
    (fun i d ->
      Printf.printf "  [%d] %s\n" i d.Devices.general_info.Devices.name)
    devs ;

  print_endline "\nRunning vector_add on each device:" ;
  print_endline (String.make 70 '-') ;
  Printf.printf "%-50s %10s %8s\n" "Device" "Time (ms)" "Status" ;
  print_endline (String.make 70 '-') ;

  let all_ok = ref true in
  Array.iter
    (fun dev ->
      let name = dev.Devices.general_info.Devices.name in
      let time_ms, ok = run_on_device dev in
      let status = if ok then "OK" else "FAIL" in
      if not ok then all_ok := false ;
      Printf.printf "%-50s %10.4f %8s\n" name time_ms status)
    devs ;

  print_endline (String.make 70 '-') ;

  if !all_ok then print_endline "\n=== All devices PASSED ==="
  else begin
    print_endline "\n=== Some devices FAILED ===" ;
    exit 1
  end
