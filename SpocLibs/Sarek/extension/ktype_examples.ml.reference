(******************************************************************************
 * ktype Examples - Reference for PPX Implementation
 *
 * These kernels use ktype, klet, and pattern matching features.
 * They are kept as reference targets for the PPX implementation.
 *
 * Note: This file is not compiled - it's documentation/reference only.
 * The camlp4 version has Ctypes compatibility issues that prevent
 * direct IR extraction.
 ******************************************************************************)

open Spoc
open Sarek
open Kirc

(* ============================================================================
 * ktype Record Types (from zgemm)
 * ============================================================================ *)

ktype complex = {mutable re : float; mutable im : float;}

let k_complex_add = kern (a : complex vector) (b : complex vector) (c : complex vector) ->
  let open Std in
  let tid = thread_idx_x in
  let x = a.[<tid>] in
  let y = b.[<tid>] in
  c.[<tid>] <- {re = x.re +. y.re; im = x.im +. y.im}

let k_complex_mul = kern (a : complex vector) (b : complex vector) (c : complex vector) ->
  let open Std in
  let tid = thread_idx_x in
  let x = a.[<tid>] in
  let y = b.[<tid>] in
  c.[<tid>] <- {re = x.re *. y.re -. x.im *. y.im;
                im = x.im *. y.re +. x.re *. y.im}

(* ============================================================================
 * ktype with klet (from ray.ml)
 * ============================================================================ *)

ktype point3 = {x : float; y : float; z : float;}
ktype color = {r : float; g : float; b : float;}

klet point_add = fun a b ->
  {x = a.x +. b.x; y = a.y +. b.y; z = a.z +. b.z}

klet point_sub = fun a b ->
  {x = a.x -. b.x; y = a.y -. b.y; z = a.z -. b.z}

klet point_scale = fun p s ->
  {x = p.x *. s; y = p.y *. s; z = p.z *. s}

klet dotprod = fun a b ->
  a.x *. b.x +. a.y *. b.y +. a.z *. b.z

klet point_mag = fun p ->
  Math.Float32.sqrt (dotprod p p)

klet unit_length = fun p ->
  let mag = point_mag p in
  {x = p.x /. mag; y = p.y /. mag; z = p.z /. mag}

let k_point_operations = kern (points : point3 vector) (result : float32 vector) ->
  let open Std in
  let tid = thread_idx_x in
  let a = points.[<tid * 2>] in
  let b = points.[<tid * 2 + 1>] in
  let sum = point_add a b in
  let diff = point_sub a b in
  result.[<tid * 3>] <- dotprod a b;
  result.[<tid * 3 + 1>] <- point_mag sum;
  result.[<tid * 3 + 2>] <- point_mag diff

(* ============================================================================
 * ktype Variants / ADTs (from ray.ml)
 * ============================================================================ *)

ktype sphere = {
  spos : point3;
  radius : float;
  scol : color;
}

ktype plane = {
  ppos : point3;
  norm : point3;
  pcol : color;
}

ktype obj =
  | Sphere of sphere
  | Plane of plane

ktype hit = {dist : float; obj : obj;}

ktype matchres =
  | MatchMiss
  | MatchHit of hit

(* ============================================================================
 * Pattern Matching (from ray.ml)
 * ============================================================================ *)

klet get_color = fun o ->
  match o with
  | Sphere s -> s.scol
  | Plane p -> p.pcol

klet get_position = fun o ->
  match o with
  | Sphere s -> s.spos
  | Plane p -> p.ppos

let k_pattern_match_simple = kern (objects : obj vector) (colors : color vector) ->
  let open Std in
  let tid = thread_idx_x in
  let obj = objects.[<tid>] in
  colors.[<tid>] <- get_color obj

klet process_hit = fun h ->
  match h with
  | MatchMiss -> 0.0
  | MatchHit hit -> hit.dist

let k_pattern_match_result = kern (hits : matchres vector) (dists : float32 vector) ->
  let open Std in
  let tid = thread_idx_x in
  dists.[<tid>] <- process_hit hits.[<tid>]

(* ============================================================================
 * Simpler variant usage
 * ============================================================================ *)

klet check_hit = fun h threshold ->
  match h with
  | MatchMiss -> false
  | MatchHit hit -> hit.dist <. threshold

let k_check_hits = kern (hits : matchres vector) (results : int32 vector) (threshold : float32) ->
  let open Std in
  let tid = thread_idx_x in
  if check_hit hits.[<tid>] threshold then
    results.[<tid>] <- 1
  else
    results.[<tid>] <- 0

(* ============================================================================
 * Matrix multiplication with ktype using klet (from zgemm)
 * ============================================================================ *)

klet complex_mul = fun c d ->
  {re = c.re *. d.re -. c.im *. d.im;
   im = c.im *. d.re +. c.re *. d.im;}

klet complex_add = fun c d ->
  {re = c.re +. d.re; im = c.im +. d.im;}

let k_matmult_complex = kern (cva : complex vector) (cvb : complex vector) (cvc : complex vector) (n : int32) ->
  let open Std in
  let row = thread_idx_y + block_dim_y * block_idx_y in
  let col = thread_idx_x + block_dim_x * block_idx_x in
  let mutable sum = {re = 0.; im = 0.} in
  if row < n && col < n then
    (
      for i = 0 to n - 1 do
        sum := complex_add sum (complex_mul cva.[<row*n+i>] cvb.[<i*n+col>]);
      done;
      cvc.[<row*n+col>] <- sum
    )
  else ()

(* ============================================================================
 * Color operations (from ray.ml)
 * ============================================================================ *)

klet add_color = fun c1 c2 ->
  {r = c1.r +. c2.r; g = c1.g +. c2.g; b = c1.b +. c2.b}

klet scale_color = fun c s ->
  {r = c.r *. s; g = c.g *. s; b = c.b *. s}

klet mul_color = fun c1 c2 ->
  {r = c1.r *. c2.r; g = c1.g *. c2.g; b = c1.b *. c2.b}

klet clamp = fun (x : float) ->
  if x <. 0.0 then 0.0
  else if x >. 1.0 then 1.0
  else x

klet clamp_color = fun c ->
  {r = clamp c.r; g = clamp c.g; b = clamp c.b}

let k_color_blend = kern (c1 : color vector) (c2 : color vector) (t : float32) (result : color vector) ->
  let open Std in
  let tid = thread_idx_x in
  let a = c1.[<tid>] in
  let b = c2.[<tid>] in
  let blended = add_color (scale_color a (1.0 -. t)) (scale_color b t) in
  result.[<tid>] <- clamp_color blended
