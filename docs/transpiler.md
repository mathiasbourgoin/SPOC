---
layout: index_sample
title: Sarek Transpiler Inspector
---

# Technical Inspector

See exactly how Sarek translates your high-level OCaml kernels into native GPU code. 

## Vector Addition

<div class="code-tabs">
  <div class="tab-headers">
    <div class="tab-header active">OCaml (Sarek)</div>
    <div class="tab-header">Generated CUDA</div>
    <div class="tab-header">Generated OpenCL</div>
  </div>
  
  <div class="tab-content active">
```ocaml
let%kernel vector_add (a : float32 vector) (b : float32 vector) (c : float32 vector) =
  let idx = get_global_id 0 in
  c.(idx) <- a.(idx) + b.(idx)
```
  </div>
  
  <div class="tab-content">
```cuda
// Auto-generated by Sarek CUDA Backend
extern "C" __global__ void vector_add(
    float* a, int sarek_a_len,
    float* b, int sarek_b_len,
    float* c, int sarek_c_len
) {
    int idx = blockIdx.x * blockDim.x + threadIdx.x;
    if (idx < sarek_a_len) {
        c[idx] = a[idx] + b[idx];
    }
}
```
  </div>

  <div class="tab-content">
```opencl
// Auto-generated by Sarek OpenCL Backend
__kernel void vector_add(
    __global float* a, int sarek_a_len,
    __global float* b, int sarek_b_len,
    __global float* c, int sarek_c_len
) {
    int idx = get_global_id(0);
    if (idx < sarek_a_len) {
        c[idx] = a[idx] + b[idx];
    }
}
```
  </div>
</div>

## Shared Memory Reduction

<div class="code-tabs">
  <div class="tab-headers">
    <div class="tab-header active">OCaml (Sarek)</div>
    <div class="tab-header">Generated CUDA</div>
  </div>
  
  <div class="tab-content active">
```ocaml
let%kernel reduce (input : float32 vector) (output : float32 vector) =
  let%shared sdata = Array.create Float32 256 in
  let tid = thread_idx_x in
  
  let%superstep load =
    sdata.(tid) <- input.(get_global_id 0)
  in
  
  (* Logic simplified for display *)
  if tid < 128 then sdata.(tid) <- sdata.(tid) + sdata.(tid + 128);
  barrier ();
  
  if tid = 0 then output.(block_idx_x) <- sdata.(0)
```
  </div>
  
  <div class="tab-content">
```cuda
extern "C" __global__ void reduce(float* input, float* output) {
    __shared__ float sdata[256];
    int tid = threadIdx.x;
    int gid = blockIdx.x * blockDim.x + threadIdx.x;

    // Superstep: load
    sdata[tid] = input[gid];
    __syncthreads();

    // Reduction logic
    if (tid < 128) {
        sdata[tid] = sdata[tid] + sdata[tid + 128];
    }
    __syncthreads();

    if (tid == 0) {
        output[blockIdx.x] = sdata[0];
    }
}
```
  </div>
</div>

## Key Takeaways
- **No Overhead**: Sarek doesn't add OCaml runtime logic to your kernels. The generated code is identical to what a human would write in C.
- **Type Safety**: Sarek handles the complex mapping of OCaml records to C structs and ensures array accesses are handled correctly.
- **Unified Logic**: You write the math once; Sarek handles the backend-specific boilerplate (`__global__`, `__kernel`, `get_global_id`, etc.).
