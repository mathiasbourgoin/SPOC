# Mandelbrot Set

Generates the famous Mandelbrot fractal using iterative complex arithmetic on the GPU.

![Mandelbrot Set Visualization](images/mandelbrot_example.png)

## Description

The Mandelbrot set is generated by iterating the complex function **z = z² + c** for each point c in the complex plane. Points that don't diverge (stay bounded) after many iterations belong to the set (colored black), while points that diverge are colored based on how quickly they escape.

For each pixel at position (px, py):
1. Map to complex coordinates: c = x0 + i·y0
2. Iterate: z_{n+1} = z_n² + c
3. Count iterations until |z| > 2 (divergence) or max_iter reached
4. Color pixel based on iteration count

## Why It Matters

Mandelbrot is a **classic GPU benchmark** that demonstrates:
- **High arithmetic intensity**: Many floating-point operations per pixel
- **Divergent execution**: Different pixels require different iteration counts
- **Beautiful output**: Visual verification of correctness
- **Real-world use case**: Scientific visualization, fractal generation

This tests:
- **Branch divergence handling**: Threads in same warp take different paths
- **Floating-point performance**: Heavy use of FP multiply and add
- **Irregular workloads**: Non-uniform iteration counts across image
- **Complex arithmetic**: Tests compiler's ability to handle complex operations

## Sarek Kernel

```ocaml
[%kernel
  fun (output : int32 vector)
      (width : int32)
      (height : int32)
      (max_iter : int32) ->
    let open Std in
    let px = global_idx_x in
    let py = global_idx_y in
    if px < width && py < height then begin
      (* Map pixel to complex plane *)
      let x0 = (4.0 *. (float px /. float width)) -. 2.5 in
      let y0 = (3.0 *. (float py /. float height)) -. 1.5 in
      
      (* Iterate z = z² + c *)
      let x = mut 0.0 in
      let y = mut 0.0 in
      let iter = mut 0l in
      
      while (x *. x) +. (y *. y) <= 4.0 && iter < max_iter do
        let xtemp = (x *. x) -. (y *. y) +. x0 in
        y := (2.0 *. x *. y) +. y0;
        x := xtemp;
        iter := iter + 1l
      done;
      
      output.((py * width) + px) <- iter
    end]
```

## Key Features

- **Mutable variables**: Uses `mut` for x, y, and iteration counter
- **Complex arithmetic**: Implements z² + c manually (no complex type needed)
- **While loop**: Dynamic iteration count (divergent execution)
- **2D grid launch**: Uses global_idx_x/y for natural pixel mapping
- **Branch divergence**: Neighboring pixels may iterate different amounts

## Performance Characteristics

| Metric | Value |
|--------|-------|
| Arithmetic Intensity | Very High (50-200 FLOPs per pixel) |
| Memory Pattern | One write per pixel (very light) |
| Divergence | High (iteration counts vary widely) |
| Typical Performance | 10-100 Megapixels/second |
| Resolution | Usually 512×512 to 4096×4096 |

## Optimization Notes

The Mandelbrot kernel is:
- **Compute-bound**: Performance limited by FP arithmetic, not memory
- **Divergence-heavy**: Warp efficiency drops when threads diverge
- **Cache-friendly**: Minimal memory traffic allows data to stay in registers

Typical iteration counts:
- Inside set (black): Full max_iter (256+)
- Edge (detailed): 20-200 iterations
- Far outside (solid colors): 1-10 iterations

This creates **high branch divergence** in edge regions where the fractal has fine detail.

## Output

The benchmark generates:
- **JSON performance data**: Timing and throughput metrics
- **PPM images**: Beautiful fractal visualizations for each device/size

Images saved as: `mandelbrot_{device}_{backend}_{width}x{height}.ppm`

Convert to PNG with ImageMagick:
```bash
convert mandelbrot_*.ppm mandelbrot.png
```
