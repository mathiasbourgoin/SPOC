(******************************************************************************)
(* SPDX-License-Identifier: CECILL-B                                         *)
(* SPDX-FileCopyrightText: 2026 Mathias Bourgoin <mathias.bourgoin@gmail.com> *)
(******************************************************************************)

(******************************************************************************
 * Sarek_type_helpers - Type-safe interpreter helper registry
 *
 * Generated by [@@sarek.type] PPX for custom type conversion.
 * Each [@@sarek.type] record type gets a helper module registered here.
 ******************************************************************************)

open Sarek_value

(** Module signature for type-specific helpers *)
module type HELPERS = sig
  type t

  val from_values : value array -> t

  val to_values : t -> value array

  val get_field : t -> string -> value

  (** Convert to VRecord representation *)
  val to_value : t -> value

  (** Convert from VRecord representation *)
  val from_value : value -> t
end

(** First-class module wrapper for helpers - fully type-safe! *)
type any_helpers =
  | AnyHelpers : (module HELPERS with type t = 'a) -> any_helpers

(** Global registry mapping type names to their helper modules *)
let registry : (string, any_helpers) Hashtbl.t = Hashtbl.create 32

(** Register a helper module for a type. Called by generated code at module
    init. *)
let register (type_name : string) (helpers : any_helpers) : unit =
  Hashtbl.replace registry type_name helpers

(** Helper functions for custom type conversion *)
type helpers = {
  from_values : value array -> value;  (** Construct VRecord from field array *)
  to_values : value -> value array;  (** Deconstruct VRecord to field array *)
  get_field : value -> string -> value;  (** Field access from VRecord *)
  to_value : 'a. 'a -> value;  (** Convert native record to VRecord *)
  from_value : 'a. value -> 'a;  (** Convert VRecord to native record *)
}

(** Look up helpers for a type. Returns None if not registered. *)
let lookup (type_name : string) : helpers option =
  match Hashtbl.find_opt registry type_name with
  | None -> None
  | Some (AnyHelpers h) ->
      (* Unpack the existential first-class module *)
      let (module H) = h in
      Some
        {
          from_values = (fun arr -> H.to_value (H.from_values arr));
          to_values = (fun v -> H.to_values (H.from_value v));
          get_field = (fun v field -> H.get_field (H.from_value v) field);
          to_value = (fun record -> H.to_value (Obj.obj (Obj.repr record)));
          from_value = (fun v -> Obj.obj (Obj.repr (H.from_value v)));
        }

(** Check if a type has registered helpers *)
let has_helpers (type_name : string) : bool = Hashtbl.mem registry type_name
