<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link rel="icon" href="/Sarek/preview/pr-119/favicon.ico" />
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.0/jquery.min.js"></script>
    <script src="/Sarek/preview/pr-119/javascripts/process-rel-links.js" type="text/javascript"></script>
    <title>GPGPU Concepts in Sarek - Sarek</title>
    
    <link rel="stylesheet" href='/Sarek/preview/pr-119/stylesheets/modern.css'>
    <link rel="stylesheet" href='/Sarek/preview/pr-119/stylesheets/pygment_trac.css'>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>
  <body>

    <!-- Top Navigation Bar -->
    <nav class="navbar">
      <div class="container">
        <a href="/Sarek/preview/pr-119/" class="nav-brand">
          <img src="/Sarek/preview/pr-119/pres_resources/logo_sarek.png" alt="Sarek Logo">
          Sarek
        </a>
        <div class="nav-links">
          <a href="/Sarek/preview/pr-119/">Home</a>
          <a href="/Sarek/preview/pr-119/docs/getting_started.html">Getting Started</a>
          <a href="/Sarek/preview/pr-119/benchmarks/">Benchmarks</a>
          <a href="/Sarek/preview/pr-119/examples/">Examples</a>
          <div class="nav-dropdown">
            <a href="#" class="dropdown-toggle">Docs ‚ñæ</a>
            <div class="dropdown-menu">
              <a href="/Sarek/preview/pr-119/docs/concepts.html">Concepts</a>
              <a href="/Sarek/preview/pr-119/docs/architecture.html">Architecture</a>
              <a href="/Sarek/preview/pr-119/docs/backends.html">Backends</a>
              <a href="/Sarek/preview/pr-119/docs/build_guide.html">Build Guide</a>
              <a href="/Sarek/preview/pr-119/docs/faq.html">FAQ</a>
              <a href="/Sarek/preview/pr-119/docs/publications.html">Publications</a>
            </div>
          </div>
          <a href="/Sarek/preview/pr-119/spoc_docs/index.html">API</a>
          <a href="https://github.com/mathiasbourgoin/Sarek">GitHub</a>
          <button id="theme-toggle" title="Toggle Dark/Light Mode">
            <span>üåô</span>
          </button>
        </div>
      </div>
    </nav>

    <main class="main-content">
      <div class="container">
        <h1 id="gpgpu-concepts-in-sarek">GPGPU Concepts in Sarek</h1>

<p>If you are coming from standard OCaml development, GPU programming requires a mental shift from ‚ÄúTask Parallelism‚Äù (like OCaml Domains) to ‚ÄúData Parallelism‚Äù (SIMT).</p>

<h2 id="the-simt-model">The SIMT Model</h2>
<p><strong>SIMT</strong> stands for <em>Single Instruction, Multiple Threads</em>.</p>

<p>In OCaml, if you want to process an array, you might use <code class="language-plaintext highlighter-rouge">Array.map</code>. On a GPU, you write a <strong>Kernel</strong> (a single function) that is executed by thousands of threads simultaneously. Each thread knows its own ID and uses it to decide which piece of data to process.</p>

<h2 id="1-execution-hierarchy-threads--blocks">1. Execution Hierarchy: Threads &amp; Blocks</h2>

<p>Sarek organizes parallel execution into a 3D hierarchy:</p>

<ul>
  <li><strong>Thread</strong>: The smallest unit of execution.</li>
  <li><strong>Block</strong> (or Work-group): A collection of threads that can communicate and synchronize with each other.</li>
  <li><strong>Grid</strong>: The total set of all blocks launched for a kernel.</li>
</ul>

<p>In Sarek, you define these dimensions using <code class="language-plaintext highlighter-rouge">(x, y, z)</code> tuples. For example, a grid of <code class="language-plaintext highlighter-rouge">(4, 1, 1)</code> with blocks of <code class="language-plaintext highlighter-rouge">(256, 1, 1)</code> results in 1024 total threads.</p>

<h3 id="terminology-mapping">Terminology Mapping</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">thread_idx_x</code>: The ID of the thread within its block.</li>
  <li><code class="language-plaintext highlighter-rouge">block_idx_x</code>: The ID of the block within the grid.</li>
  <li><code class="language-plaintext highlighter-rouge">global_thread_id</code>: The unique ID of the thread across the entire grid.</li>
</ul>

<h2 id="2-memory-hierarchy">2. Memory Hierarchy</h2>

<p>GPU memory is not flat. Choosing the right memory space is the key to performance.</p>

<h3 id="global-memory-vectort">Global Memory (<code class="language-plaintext highlighter-rouge">Vector.t</code>)</h3>
<p>This is the main GPU memory. It is large but slow. Data transferred from OCaml via <code class="language-plaintext highlighter-rouge">Vector</code> lives here. All threads in all blocks can read/write to it.</p>

<h3 id="shared-memory-letshared">Shared Memory (<code class="language-plaintext highlighter-rouge">let%shared</code>)</h3>
<p>Shared memory is a small, ultra-fast cache shared by all threads <strong>within the same block</strong>. It is used for collaborative computing (like reductions or matrix tiles).</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span><span class="o">%</span><span class="n">shared</span> <span class="n">sdata</span> <span class="o">=</span> <span class="nn">Array</span><span class="p">.</span><span class="n">create</span> <span class="nc">Float32</span> <span class="mi">256</span> <span class="k">in</span> <span class="c">(* Shared by 256 threads *)</span>
</code></pre></div></div>

<h3 id="local-memory">Local Memory</h3>
<p>Standard variables (<code class="language-plaintext highlighter-rouge">let x = ...</code> or <code class="language-plaintext highlighter-rouge">let mut x = ...</code>) are local to a single thread and usually stored in high-speed registers.</p>

<h2 id="3-synchronization--supersteps">3. Synchronization &amp; Supersteps</h2>

<p>Because threads run in parallel, they often need to wait for each other.</p>

<h3 id="barriers">Barriers</h3>
<p>A <code class="language-plaintext highlighter-rouge">barrier()</code> call forces every thread in a block to reach that point before any can proceed. This ensures that memory writes from one thread are visible to others.</p>

<h3 id="supersteps-sarekbsp-model">Supersteps (Sarek/BSP Model)</h3>
<p>Sarek introduces the concept of <strong>Supersteps</strong>, derived from the Bulk Synchronous Parallel (BSP) model. A <code class="language-plaintext highlighter-rouge">let%superstep</code> block is a clean way to organize phases of computation separated by implicit barriers.</p>
<div class="language-ocaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span><span class="o">%</span><span class="n">superstep</span> <span class="n">loading_phase</span> <span class="o">=</span> 
  <span class="n">sdata</span><span class="o">.</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="o">&lt;-</span> <span class="n">input</span><span class="o">.</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span>
<span class="k">in</span>
<span class="c">(* Threads automatically synchronize here *)</span>
<span class="k">let</span><span class="o">%</span><span class="n">superstep</span> <span class="n">computing_phase</span> <span class="o">=</span> 
  <span class="n">process</span> <span class="n">sdata</span><span class="o">.</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
<span class="k">in</span>
<span class="o">...</span>
</code></pre></div></div>

<h2 id="4-host--device-transfers">4. Host &amp; Device Transfers</h2>

<ul>
  <li><strong>Host</strong>: Your CPU running OCaml.</li>
  <li><strong>Device</strong>: The GPU.</li>
</ul>

<p>The CPU and GPU usually have separate memory. Before running a kernel, you must <strong>transfer</strong> your data to the device. Sarek manages this through <code class="language-plaintext highlighter-rouge">Vector</code> handles.</p>
<ul>
  <li>When you pass a <code class="language-plaintext highlighter-rouge">Vec a</code> to <code class="language-plaintext highlighter-rouge">Execute.run</code>, Sarek ensures the data is present on the GPU.</li>
  <li>When you call <code class="language-plaintext highlighter-rouge">Vector.get</code> or <code class="language-plaintext highlighter-rouge">Vector.to_array</code>, Sarek pulls the data back to the OCaml heap.</li>
</ul>

<h2 id="summary-checklist">Summary Checklist</h2>
<ol>
  <li><strong>Define Kernel</strong>: Write the logic using Sarek PPX.</li>
  <li><strong>Transfer Data</strong>: Initialize <code class="language-plaintext highlighter-rouge">Vector</code> objects.</li>
  <li><strong>Configure Layout</strong>: Decide on <code class="language-plaintext highlighter-rouge">grid</code> and <code class="language-plaintext highlighter-rouge">block</code> sizes.</li>
  <li><strong>Run</strong>: Dispatch to CUDA, OpenCL, Vulkan, or Metal.</li>
  <li><strong>Sync</strong>: Retrieve results.</li>
</ol>

      </div>
    </main>

    <footer>
      <div class="container">
        <p>Sarek is maintained by <a href="https://github.com/mathiasbourgoin">mathiasbourgoin</a></p>
        <p>Hosted on GitHub Pages</p>
      </div>
    </footer>

    <script src="/Sarek/preview/pr-119/javascripts/scale.fix.js"></script>
    <script src="/Sarek/preview/pr-119/javascripts/copy-code.js"></script>
    <script src="/Sarek/preview/pr-119/javascripts/theme-toggle.js"></script>
    <script src="/Sarek/preview/pr-119/javascripts/syntax-sarek.js"></script>
  </body>
</html>
