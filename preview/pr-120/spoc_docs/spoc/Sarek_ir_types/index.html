<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sarek_ir_types (spoc.Sarek_ir_types)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">Index</a> &#x00BB; <a href="../index.html">spoc</a> &#x00BB; Sarek_ir_types</nav><header class="odoc-preamble"><h1>Module <code><span>Sarek_ir_types</span></code></h1><p>Sarek_ir_types - Pure type definitions for GPU kernel IR</p><p>This module contains only type definitions with no external dependencies. Used by spoc_framework for typed generate_source signature.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#typed-helpers-for-custom-types">Typed Helpers for Custom Types</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-memspace"><a href="#type-memspace" class="anchor"></a><code><span><span class="keyword">type</span> memspace</span><span> = </span></code><ol><li id="type-memspace.Global" class="def variant constructor anchored"><a href="#type-memspace.Global" class="anchor"></a><code><span>| </span><span><span class="constructor">Global</span></span></code></li><li id="type-memspace.Shared" class="def variant constructor anchored"><a href="#type-memspace.Shared" class="anchor"></a><code><span>| </span><span><span class="constructor">Shared</span></span></code></li><li id="type-memspace.Local" class="def variant constructor anchored"><a href="#type-memspace.Local" class="anchor"></a><code><span>| </span><span><span class="constructor">Local</span></span></code></li></ol></div><div class="spec-doc"><p>Memory spaces</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-elttype"><a href="#type-elttype" class="anchor"></a><code><span><span class="keyword">type</span> elttype</span><span> = </span></code><ol><li id="type-elttype.TInt32" class="def variant constructor anchored"><a href="#type-elttype.TInt32" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt32</span></span></code></li><li id="type-elttype.TInt64" class="def variant constructor anchored"><a href="#type-elttype.TInt64" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt64</span></span></code></li><li id="type-elttype.TFloat32" class="def variant constructor anchored"><a href="#type-elttype.TFloat32" class="anchor"></a><code><span>| </span><span><span class="constructor">TFloat32</span></span></code></li><li id="type-elttype.TFloat64" class="def variant constructor anchored"><a href="#type-elttype.TFloat64" class="anchor"></a><code><span>| </span><span><span class="constructor">TFloat64</span></span></code></li><li id="type-elttype.TBool" class="def variant constructor anchored"><a href="#type-elttype.TBool" class="anchor"></a><code><span>| </span><span><span class="constructor">TBool</span></span></code></li><li id="type-elttype.TUnit" class="def variant constructor anchored"><a href="#type-elttype.TUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">TUnit</span></span></code></li><li id="type-elttype.TRecord" class="def variant constructor anchored"><a href="#type-elttype.TRecord" class="anchor"></a><code><span>| </span><span><span class="constructor">TRecord</span> <span class="keyword">of</span> string * <span><span>(string * <a href="#type-elttype">elttype</a>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record type: name and field list</p><span class="comment-delim">*)</span></div></li><li id="type-elttype.TVariant" class="def variant constructor anchored"><a href="#type-elttype.TVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">TVariant</span> <span class="keyword">of</span> string * <span><span>(string * <span><a href="#type-elttype">elttype</a> list</span>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variant type: name and constructor list with arg types</p><span class="comment-delim">*)</span></div></li><li id="type-elttype.TArray" class="def variant constructor anchored"><a href="#type-elttype.TArray" class="anchor"></a><code><span>| </span><span><span class="constructor">TArray</span> <span class="keyword">of</span> <a href="#type-elttype">elttype</a> * <a href="#type-memspace">memspace</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array type with element type and memory space</p><span class="comment-delim">*)</span></div></li><li id="type-elttype.TVec" class="def variant constructor anchored"><a href="#type-elttype.TVec" class="anchor"></a><code><span>| </span><span><span class="constructor">TVec</span> <span class="keyword">of</span> <a href="#type-elttype">elttype</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Vector (GPU array parameter)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Element types</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-var"><a href="#type-var" class="anchor"></a><code><span><span class="keyword">type</span> var</span><span> = </span><span>{</span></code><ol><li id="type-var.var_name" class="def record field anchored"><a href="#type-var.var_name" class="anchor"></a><code><span>var_name : string;</span></code></li><li id="type-var.var_id" class="def record field anchored"><a href="#type-var.var_id" class="anchor"></a><code><span>var_id : int;</span></code></li><li id="type-var.var_type" class="def record field anchored"><a href="#type-var.var_type" class="anchor"></a><code><span>var_type : <a href="#type-elttype">elttype</a>;</span></code></li><li id="type-var.var_mutable" class="def record field anchored"><a href="#type-var.var_mutable" class="anchor"></a><code><span>var_mutable : bool;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Variables with type info</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-const"><a href="#type-const" class="anchor"></a><code><span><span class="keyword">type</span> const</span><span> = </span></code><ol><li id="type-const.CInt32" class="def variant constructor anchored"><a href="#type-const.CInt32" class="anchor"></a><code><span>| </span><span><span class="constructor">CInt32</span> <span class="keyword">of</span> int32</span></code></li><li id="type-const.CInt64" class="def variant constructor anchored"><a href="#type-const.CInt64" class="anchor"></a><code><span>| </span><span><span class="constructor">CInt64</span> <span class="keyword">of</span> int64</span></code></li><li id="type-const.CFloat32" class="def variant constructor anchored"><a href="#type-const.CFloat32" class="anchor"></a><code><span>| </span><span><span class="constructor">CFloat32</span> <span class="keyword">of</span> float</span></code></li><li id="type-const.CFloat64" class="def variant constructor anchored"><a href="#type-const.CFloat64" class="anchor"></a><code><span>| </span><span><span class="constructor">CFloat64</span> <span class="keyword">of</span> float</span></code></li><li id="type-const.CBool" class="def variant constructor anchored"><a href="#type-const.CBool" class="anchor"></a><code><span>| </span><span><span class="constructor">CBool</span> <span class="keyword">of</span> bool</span></code></li><li id="type-const.CUnit" class="def variant constructor anchored"><a href="#type-const.CUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">CUnit</span></span></code></li></ol></div><div class="spec-doc"><p>Constants</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-binop"><a href="#type-binop" class="anchor"></a><code><span><span class="keyword">type</span> binop</span><span> = </span></code><ol><li id="type-binop.Add" class="def variant constructor anchored"><a href="#type-binop.Add" class="anchor"></a><code><span>| </span><span><span class="constructor">Add</span></span></code></li><li id="type-binop.Sub" class="def variant constructor anchored"><a href="#type-binop.Sub" class="anchor"></a><code><span>| </span><span><span class="constructor">Sub</span></span></code></li><li id="type-binop.Mul" class="def variant constructor anchored"><a href="#type-binop.Mul" class="anchor"></a><code><span>| </span><span><span class="constructor">Mul</span></span></code></li><li id="type-binop.Div" class="def variant constructor anchored"><a href="#type-binop.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code></li><li id="type-binop.Mod" class="def variant constructor anchored"><a href="#type-binop.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code></li><li id="type-binop.Eq" class="def variant constructor anchored"><a href="#type-binop.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code></li><li id="type-binop.Ne" class="def variant constructor anchored"><a href="#type-binop.Ne" class="anchor"></a><code><span>| </span><span><span class="constructor">Ne</span></span></code></li><li id="type-binop.Lt" class="def variant constructor anchored"><a href="#type-binop.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code></li><li id="type-binop.Le" class="def variant constructor anchored"><a href="#type-binop.Le" class="anchor"></a><code><span>| </span><span><span class="constructor">Le</span></span></code></li><li id="type-binop.Gt" class="def variant constructor anchored"><a href="#type-binop.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code></li><li id="type-binop.Ge" class="def variant constructor anchored"><a href="#type-binop.Ge" class="anchor"></a><code><span>| </span><span><span class="constructor">Ge</span></span></code></li><li id="type-binop.And" class="def variant constructor anchored"><a href="#type-binop.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code></li><li id="type-binop.Or" class="def variant constructor anchored"><a href="#type-binop.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code></li><li id="type-binop.Shl" class="def variant constructor anchored"><a href="#type-binop.Shl" class="anchor"></a><code><span>| </span><span><span class="constructor">Shl</span></span></code></li><li id="type-binop.Shr" class="def variant constructor anchored"><a href="#type-binop.Shr" class="anchor"></a><code><span>| </span><span><span class="constructor">Shr</span></span></code></li><li id="type-binop.BitAnd" class="def variant constructor anchored"><a href="#type-binop.BitAnd" class="anchor"></a><code><span>| </span><span><span class="constructor">BitAnd</span></span></code></li><li id="type-binop.BitOr" class="def variant constructor anchored"><a href="#type-binop.BitOr" class="anchor"></a><code><span>| </span><span><span class="constructor">BitOr</span></span></code></li><li id="type-binop.BitXor" class="def variant constructor anchored"><a href="#type-binop.BitXor" class="anchor"></a><code><span>| </span><span><span class="constructor">BitXor</span></span></code></li></ol></div><div class="spec-doc"><p>Binary operators</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unop"><a href="#type-unop" class="anchor"></a><code><span><span class="keyword">type</span> unop</span><span> = </span></code><ol><li id="type-unop.Neg" class="def variant constructor anchored"><a href="#type-unop.Neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Neg</span></span></code></li><li id="type-unop.Not" class="def variant constructor anchored"><a href="#type-unop.Not" class="anchor"></a><code><span>| </span><span><span class="constructor">Not</span></span></code></li><li id="type-unop.BitNot" class="def variant constructor anchored"><a href="#type-unop.BitNot" class="anchor"></a><code><span>| </span><span><span class="constructor">BitNot</span></span></code></li></ol></div><div class="spec-doc"><p>Unary operators</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-for_dir"><a href="#type-for_dir" class="anchor"></a><code><span><span class="keyword">type</span> for_dir</span><span> = </span></code><ol><li id="type-for_dir.Upto" class="def variant constructor anchored"><a href="#type-for_dir.Upto" class="anchor"></a><code><span>| </span><span><span class="constructor">Upto</span></span></code></li><li id="type-for_dir.Downto" class="def variant constructor anchored"><a href="#type-for_dir.Downto" class="anchor"></a><code><span>| </span><span><span class="constructor">Downto</span></span></code></li></ol></div><div class="spec-doc"><p>Loop direction</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pattern"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">type</span> pattern</span><span> = </span></code><ol><li id="type-pattern.PConstr" class="def variant constructor anchored"><a href="#type-pattern.PConstr" class="anchor"></a><code><span>| </span><span><span class="constructor">PConstr</span> <span class="keyword">of</span> string * <span>string list</span></span></code></li><li id="type-pattern.PWild" class="def variant constructor anchored"><a href="#type-pattern.PWild" class="anchor"></a><code><span>| </span><span><span class="constructor">PWild</span></span></code></li></ol></div><div class="spec-doc"><p>Match pattern</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-expr"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">type</span> expr</span><span> = </span></code><ol><li id="type-expr.EConst" class="def variant constructor anchored"><a href="#type-expr.EConst" class="anchor"></a><code><span>| </span><span><span class="constructor">EConst</span> <span class="keyword">of</span> <a href="#type-const">const</a></span></code></li><li id="type-expr.EVar" class="def variant constructor anchored"><a href="#type-expr.EVar" class="anchor"></a><code><span>| </span><span><span class="constructor">EVar</span> <span class="keyword">of</span> <a href="#type-var">var</a></span></code></li><li id="type-expr.EBinop" class="def variant constructor anchored"><a href="#type-expr.EBinop" class="anchor"></a><code><span>| </span><span><span class="constructor">EBinop</span> <span class="keyword">of</span> <a href="#type-binop">binop</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.EUnop" class="def variant constructor anchored"><a href="#type-expr.EUnop" class="anchor"></a><code><span>| </span><span><span class="constructor">EUnop</span> <span class="keyword">of</span> <a href="#type-unop">unop</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.EArrayRead" class="def variant constructor anchored"><a href="#type-expr.EArrayRead" class="anchor"></a><code><span>| </span><span><span class="constructor">EArrayRead</span> <span class="keyword">of</span> string * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>arr<code>idx</code></p><span class="comment-delim">*)</span></div></li><li id="type-expr.EArrayReadExpr" class="def variant constructor anchored"><a href="#type-expr.EArrayReadExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">EArrayReadExpr</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>base_expr<code>idx</code> for complex bases</p><span class="comment-delim">*)</span></div></li><li id="type-expr.ERecordField" class="def variant constructor anchored"><a href="#type-expr.ERecordField" class="anchor"></a><code><span>| </span><span><span class="constructor">ERecordField</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>r.field</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EIntrinsic" class="def variant constructor anchored"><a href="#type-expr.EIntrinsic" class="anchor"></a><code><span>| </span><span><span class="constructor">EIntrinsic</span> <span class="keyword">of</span> <span>string list</span> * string * <span><a href="#type-expr">expr</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>module path, name, args</p><span class="comment-delim">*)</span></div></li><li id="type-expr.ECast" class="def variant constructor anchored"><a href="#type-expr.ECast" class="anchor"></a><code><span>| </span><span><span class="constructor">ECast</span> <span class="keyword">of</span> <a href="#type-elttype">elttype</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-expr.ETuple" class="def variant constructor anchored"><a href="#type-expr.ETuple" class="anchor"></a><code><span>| </span><span><span class="constructor">ETuple</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> list</span></span></code></li><li id="type-expr.EApp" class="def variant constructor anchored"><a href="#type-expr.EApp" class="anchor"></a><code><span>| </span><span><span class="constructor">EApp</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><a href="#type-expr">expr</a> list</span></span></code></li><li id="type-expr.ERecord" class="def variant constructor anchored"><a href="#type-expr.ERecord" class="anchor"></a><code><span>| </span><span><span class="constructor">ERecord</span> <span class="keyword">of</span> string * <span><span>(string * <a href="#type-expr">expr</a>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record construction: type name, field values</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EVariant" class="def variant constructor anchored"><a href="#type-expr.EVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">EVariant</span> <span class="keyword">of</span> string * string * <span><a href="#type-expr">expr</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variant construction: type name, constructor, args</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EArrayLen" class="def variant constructor anchored"><a href="#type-expr.EArrayLen" class="anchor"></a><code><span>| </span><span><span class="constructor">EArrayLen</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Array length intrinsic</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EArrayCreate" class="def variant constructor anchored"><a href="#type-expr.EArrayCreate" class="anchor"></a><code><span>| </span><span><span class="constructor">EArrayCreate</span> <span class="keyword">of</span> <a href="#type-elttype">elttype</a> * <a href="#type-expr">expr</a> * <a href="#type-memspace">memspace</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>elem type, size, memspace</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EIf" class="def variant constructor anchored"><a href="#type-expr.EIf" class="anchor"></a><code><span>| </span><span><span class="constructor">EIf</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>condition, then, else - value-returning if</p><span class="comment-delim">*)</span></div></li><li id="type-expr.EMatch" class="def variant constructor anchored"><a href="#type-expr.EMatch" class="anchor"></a><code><span>| </span><span><span class="constructor">EMatch</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><span>(<a href="#type-pattern">pattern</a> * <a href="#type-expr">expr</a>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>scrutinee, cases - value-returning match</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Expressions (pure, no side effects)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-lvalue"><a href="#type-lvalue" class="anchor"></a><code><span><span class="keyword">type</span> lvalue</span><span> = </span></code><ol><li id="type-lvalue.LVar" class="def variant constructor anchored"><a href="#type-lvalue.LVar" class="anchor"></a><code><span>| </span><span><span class="constructor">LVar</span> <span class="keyword">of</span> <a href="#type-var">var</a></span></code></li><li id="type-lvalue.LArrayElem" class="def variant constructor anchored"><a href="#type-lvalue.LArrayElem" class="anchor"></a><code><span>| </span><span><span class="constructor">LArrayElem</span> <span class="keyword">of</span> string * <a href="#type-expr">expr</a></span></code></li><li id="type-lvalue.LArrayElemExpr" class="def variant constructor anchored"><a href="#type-lvalue.LArrayElemExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">LArrayElemExpr</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-lvalue.LRecordField" class="def variant constructor anchored"><a href="#type-lvalue.LRecordField" class="anchor"></a><code><span>| </span><span><span class="constructor">LRecordField</span> <span class="keyword">of</span> <a href="#type-lvalue">lvalue</a> * string</span></code></li></ol></div><div class="spec-doc"><p>L-values (assignable locations)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stmt"><a href="#type-stmt" class="anchor"></a><code><span><span class="keyword">type</span> stmt</span><span> = </span></code><ol><li id="type-stmt.SAssign" class="def variant constructor anchored"><a href="#type-stmt.SAssign" class="anchor"></a><code><span>| </span><span><span class="constructor">SAssign</span> <span class="keyword">of</span> <a href="#type-lvalue">lvalue</a> * <a href="#type-expr">expr</a></span></code></li><li id="type-stmt.SSeq" class="def variant constructor anchored"><a href="#type-stmt.SSeq" class="anchor"></a><code><span>| </span><span><span class="constructor">SSeq</span> <span class="keyword">of</span> <span><a href="#type-stmt">stmt</a> list</span></span></code></li><li id="type-stmt.SIf" class="def variant constructor anchored"><a href="#type-stmt.SIf" class="anchor"></a><code><span>| </span><span><span class="constructor">SIf</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-stmt">stmt</a> * <span><a href="#type-stmt">stmt</a> option</span></span></code></li><li id="type-stmt.SWhile" class="def variant constructor anchored"><a href="#type-stmt.SWhile" class="anchor"></a><code><span>| </span><span><span class="constructor">SWhile</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-stmt">stmt</a></span></code></li><li id="type-stmt.SFor" class="def variant constructor anchored"><a href="#type-stmt.SFor" class="anchor"></a><code><span>| </span><span><span class="constructor">SFor</span> <span class="keyword">of</span> <a href="#type-var">var</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="#type-for_dir">for_dir</a> * <a href="#type-stmt">stmt</a></span></code></li><li id="type-stmt.SMatch" class="def variant constructor anchored"><a href="#type-stmt.SMatch" class="anchor"></a><code><span>| </span><span><span class="constructor">SMatch</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><span>(<a href="#type-pattern">pattern</a> * <a href="#type-stmt">stmt</a>)</span> list</span></span></code></li><li id="type-stmt.SReturn" class="def variant constructor anchored"><a href="#type-stmt.SReturn" class="anchor"></a><code><span>| </span><span><span class="constructor">SReturn</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code></li><li id="type-stmt.SBarrier" class="def variant constructor anchored"><a href="#type-stmt.SBarrier" class="anchor"></a><code><span>| </span><span><span class="constructor">SBarrier</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Block-level barrier (__syncthreads)</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SWarpBarrier" class="def variant constructor anchored"><a href="#type-stmt.SWarpBarrier" class="anchor"></a><code><span>| </span><span><span class="constructor">SWarpBarrier</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Warp-level sync (__syncwarp)</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SExpr" class="def variant constructor anchored"><a href="#type-stmt.SExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">SExpr</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Side-effecting expression</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SEmpty" class="def variant constructor anchored"><a href="#type-stmt.SEmpty" class="anchor"></a><code><span>| </span><span><span class="constructor">SEmpty</span></span></code></li><li id="type-stmt.SLet" class="def variant constructor anchored"><a href="#type-stmt.SLet" class="anchor"></a><code><span>| </span><span><span class="constructor">SLet</span> <span class="keyword">of</span> <a href="#type-var">var</a> * <a href="#type-expr">expr</a> * <a href="#type-stmt">stmt</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Let binding: let v = e in body</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SLetMut" class="def variant constructor anchored"><a href="#type-stmt.SLetMut" class="anchor"></a><code><span>| </span><span><span class="constructor">SLetMut</span> <span class="keyword">of</span> <a href="#type-var">var</a> * <a href="#type-expr">expr</a> * <a href="#type-stmt">stmt</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Mutable let: let v = ref e in body</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SPragma" class="def variant constructor anchored"><a href="#type-stmt.SPragma" class="anchor"></a><code><span>| </span><span><span class="constructor">SPragma</span> <span class="keyword">of</span> <span>string list</span> * <a href="#type-stmt">stmt</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pragma hints wrapping a statement</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SMemFence" class="def variant constructor anchored"><a href="#type-stmt.SMemFence" class="anchor"></a><code><span>| </span><span><span class="constructor">SMemFence</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Memory fence (threadfence)</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SBlock" class="def variant constructor anchored"><a href="#type-stmt.SBlock" class="anchor"></a><code><span>| </span><span><span class="constructor">SBlock</span> <span class="keyword">of</span> <a href="#type-stmt">stmt</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Scoped block - creates a C scope for variable isolation</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.SNative" class="def variant constructor anchored"><a href="#type-stmt.SNative" class="anchor"></a><code><span>| </span><span><span class="constructor">SNative</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-stmt.gpu" class="def record field anchored"><a href="#type-stmt.gpu" class="anchor"></a><code><span>gpu : <span><span class="label">framework</span>:string <span class="arrow">&#45;&gt;</span></span> string;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Generate GPU code for framework</p><span class="comment-delim">*)</span></div></li><li id="type-stmt.ocaml" class="def record field anchored"><a href="#type-stmt.ocaml" class="anchor"></a><code><span>ocaml : <a href="#type-ocaml_closure">ocaml_closure</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Typed OCaml fallback</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Inline native GPU code with OCaml fallback</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Statements (imperative, side effects)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decl"><a href="#type-decl" class="anchor"></a><code><span><span class="keyword">and</span> decl</span><span> = </span></code><ol><li id="type-decl.DParam" class="def variant constructor anchored"><a href="#type-decl.DParam" class="anchor"></a><code><span>| </span><span><span class="constructor">DParam</span> <span class="keyword">of</span> <a href="#type-var">var</a> * <span><a href="#type-array_info">array_info</a> option</span></span></code></li><li id="type-decl.DLocal" class="def variant constructor anchored"><a href="#type-decl.DLocal" class="anchor"></a><code><span>| </span><span><span class="constructor">DLocal</span> <span class="keyword">of</span> <a href="#type-var">var</a> * <span><a href="#type-expr">expr</a> option</span></span></code></li><li id="type-decl.DShared" class="def variant constructor anchored"><a href="#type-decl.DShared" class="anchor"></a><code><span>| </span><span><span class="constructor">DShared</span> <span class="keyword">of</span> string * <a href="#type-elttype">elttype</a> * <span><a href="#type-expr">expr</a> option</span></span></code></li></ol></div><div class="spec-doc"><p>Declarations</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-array_info"><a href="#type-array_info" class="anchor"></a><code><span><span class="keyword">and</span> array_info</span><span> = </span><span>{</span></code><ol><li id="type-array_info.arr_elttype" class="def record field anchored"><a href="#type-array_info.arr_elttype" class="anchor"></a><code><span>arr_elttype : <a href="#type-elttype">elttype</a>;</span></code></li><li id="type-array_info.arr_memspace" class="def record field anchored"><a href="#type-array_info.arr_memspace" class="anchor"></a><code><span>arr_memspace : <a href="#type-memspace">memspace</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-helper_func"><a href="#type-helper_func" class="anchor"></a><code><span><span class="keyword">and</span> helper_func</span><span> = </span><span>{</span></code><ol><li id="type-helper_func.hf_name" class="def record field anchored"><a href="#type-helper_func.hf_name" class="anchor"></a><code><span>hf_name : string;</span></code></li><li id="type-helper_func.hf_params" class="def record field anchored"><a href="#type-helper_func.hf_params" class="anchor"></a><code><span>hf_params : <span><a href="#type-var">var</a> list</span>;</span></code></li><li id="type-helper_func.hf_ret_type" class="def record field anchored"><a href="#type-helper_func.hf_ret_type" class="anchor"></a><code><span>hf_ret_type : <a href="#type-elttype">elttype</a>;</span></code></li><li id="type-helper_func.hf_body" class="def record field anchored"><a href="#type-helper_func.hf_body" class="anchor"></a><code><span>hf_body : <a href="#type-stmt">stmt</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Helper function (device function called from kernel)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-native_arg"><a href="#type-native_arg" class="anchor"></a><code><span><span class="keyword">and</span> native_arg</span><span> = </span></code><ol><li id="type-native_arg.NA_Int32" class="def variant constructor anchored"><a href="#type-native_arg.NA_Int32" class="anchor"></a><code><span>| </span><span><span class="constructor">NA_Int32</span> <span class="keyword">of</span> int32</span></code></li><li id="type-native_arg.NA_Int64" class="def variant constructor anchored"><a href="#type-native_arg.NA_Int64" class="anchor"></a><code><span>| </span><span><span class="constructor">NA_Int64</span> <span class="keyword">of</span> int64</span></code></li><li id="type-native_arg.NA_Float32" class="def variant constructor anchored"><a href="#type-native_arg.NA_Float32" class="anchor"></a><code><span>| </span><span><span class="constructor">NA_Float32</span> <span class="keyword">of</span> float</span></code></li><li id="type-native_arg.NA_Float64" class="def variant constructor anchored"><a href="#type-native_arg.NA_Float64" class="anchor"></a><code><span>| </span><span><span class="constructor">NA_Float64</span> <span class="keyword">of</span> float</span></code></li><li id="type-native_arg.NA_Vec" class="def variant constructor anchored"><a href="#type-native_arg.NA_Vec" class="anchor"></a><code><span>| </span><span><span class="constructor">NA_Vec</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-native_arg.length" class="def record field anchored"><a href="#type-native_arg.length" class="anchor"></a><code><span>length : int;</span></code></li><li id="type-native_arg.elem_size" class="def record field anchored"><a href="#type-native_arg.elem_size" class="anchor"></a><code><span>elem_size : int;</span></code></li><li id="type-native_arg.type_name" class="def record field anchored"><a href="#type-native_arg.type_name" class="anchor"></a><code><span>type_name : string;</span></code></li><li id="type-native_arg.get_f32" class="def record field anchored"><a href="#type-native_arg.get_f32" class="anchor"></a><code><span>get_f32 : <span>int <span class="arrow">&#45;&gt;</span></span> float;</span></code></li><li id="type-native_arg.set_f32" class="def record field anchored"><a href="#type-native_arg.set_f32" class="anchor"></a><code><span>set_f32 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-native_arg.get_f64" class="def record field anchored"><a href="#type-native_arg.get_f64" class="anchor"></a><code><span>get_f64 : <span>int <span class="arrow">&#45;&gt;</span></span> float;</span></code></li><li id="type-native_arg.set_f64" class="def record field anchored"><a href="#type-native_arg.set_f64" class="anchor"></a><code><span>set_f64 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-native_arg.get_i32" class="def record field anchored"><a href="#type-native_arg.get_i32" class="anchor"></a><code><span>get_i32 : <span>int <span class="arrow">&#45;&gt;</span></span> int32;</span></code></li><li id="type-native_arg.set_i32" class="def record field anchored"><a href="#type-native_arg.set_i32" class="anchor"></a><code><span>set_i32 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-native_arg.get_i64" class="def record field anchored"><a href="#type-native_arg.get_i64" class="anchor"></a><code><span>get_i64 : <span>int <span class="arrow">&#45;&gt;</span></span> int64;</span></code></li><li id="type-native_arg.set_i64" class="def record field anchored"><a href="#type-native_arg.set_i64" class="anchor"></a><code><span>set_i64 : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-native_arg.get_any" class="def record field anchored"><a href="#type-native_arg.get_any" class="anchor"></a><code><span>get_any : <span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Obj.t;</span></code></li><li id="type-native_arg.set_any" class="def record field anchored"><a href="#type-native_arg.set_any" class="anchor"></a><code><span>set_any : <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.Obj.t <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li><li id="type-native_arg.get_vec" class="def record field anchored"><a href="#type-native_arg.get_vec" class="anchor"></a><code><span>get_vec : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Stdlib</span>.Obj.t;</span></code></li></ol><code><span>}</span></code></li></ol></div><div class="spec-doc"><p>Native argument type for kernel execution. Typed arguments without Obj.t - used by PPX-generated native functions.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-ocaml_closure"><a href="#type-ocaml_closure" class="anchor"></a><code><span><span class="keyword">and</span> ocaml_closure</span><span> = </span><span>{</span></code><ol><li id="type-ocaml_closure.run" class="def record field anchored"><a href="#type-ocaml_closure.run" class="anchor"></a><code><span>run : <span><span class="label">block</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">grid</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-native_arg">native_arg</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  unit;</span></code></li></ol><code><span>}</span></code></div></div><h3 id="typed-helpers-for-custom-types"><a href="#typed-helpers-for-custom-types" class="anchor"></a>Typed Helpers for Custom Types</h3><p>These functions encapsulate the Obj operations so that PPX-generated code doesn't need to use Obj directly. The type parameter is inferred from context.</p><div class="odoc-spec"><div class="spec value anchored" id="val-vec_get_custom"><a href="#val-vec_get_custom" class="anchor"></a><code><span><span class="keyword">val</span> vec_get_custom : 'a. <span><a href="#type-native_arg">native_arg</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Get element from NA_Vec as custom type. Type is inferred from usage.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vec_set_custom"><a href="#val-vec_set_custom" class="anchor"></a><code><span><span class="keyword">val</span> vec_set_custom : 'a. <span><a href="#type-native_arg">native_arg</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Set element in NA_Vec from custom type. Type is inferred from usage.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vec_length"><a href="#val-vec_length" class="anchor"></a><code><span><span class="keyword">val</span> vec_length : <span><a href="#type-native_arg">native_arg</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Get length from NA_Vec</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-vec_as_vector"><a href="#val-vec_as_vector" class="anchor"></a><code><span><span class="keyword">val</span> vec_as_vector : 'a. <span><a href="#type-native_arg">native_arg</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Get underlying vector. Used when passing vectors to functions/intrinsics that need the actual Vector.t type. Returns type-erased value that the caller casts to the appropriate Vector.t type.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-native_fn_t"><a href="#type-native_fn_t" class="anchor"></a><code><span><span class="keyword">type</span> native_fn_t</span><span> = </span></code><ol><li id="type-native_fn_t.NativeFn" class="def variant constructor anchored"><a href="#type-native_fn_t.NativeFn" class="anchor"></a><code><span>| </span><span><span class="constructor">NativeFn</span> <span class="keyword">of</span> <span><span class="label">parallel</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">block</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">grid</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="#type-native_arg">native_arg</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></li></ol></div><div class="spec-doc"><p>Native function type for V2 execution. Uses typed native_arg.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-kernel"><a href="#type-kernel" class="anchor"></a><code><span><span class="keyword">type</span> kernel</span><span> = </span><span>{</span></code><ol><li id="type-kernel.kern_name" class="def record field anchored"><a href="#type-kernel.kern_name" class="anchor"></a><code><span>kern_name : string;</span></code></li><li id="type-kernel.kern_params" class="def record field anchored"><a href="#type-kernel.kern_params" class="anchor"></a><code><span>kern_params : <span><a href="#type-decl">decl</a> list</span>;</span></code></li><li id="type-kernel.kern_locals" class="def record field anchored"><a href="#type-kernel.kern_locals" class="anchor"></a><code><span>kern_locals : <span><a href="#type-decl">decl</a> list</span>;</span></code></li><li id="type-kernel.kern_body" class="def record field anchored"><a href="#type-kernel.kern_body" class="anchor"></a><code><span>kern_body : <a href="#type-stmt">stmt</a>;</span></code></li><li id="type-kernel.kern_types" class="def record field anchored"><a href="#type-kernel.kern_types" class="anchor"></a><code><span>kern_types : <span><span>(string * <span><span>(string * <a href="#type-elttype">elttype</a>)</span> list</span>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record type definitions: (type_name, <code>(field_name, field_type); ...</code>)</p><span class="comment-delim">*)</span></div></li><li id="type-kernel.kern_variants" class="def record field anchored"><a href="#type-kernel.kern_variants" class="anchor"></a><code><span>kern_variants : <span><span>(string * <span><span>(string * <span><a href="#type-elttype">elttype</a> list</span>)</span> list</span>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variant type definitions: (type_name, <code>(constructor_name, payload_types); ...</code>)</p><span class="comment-delim">*)</span></div></li><li id="type-kernel.kern_funcs" class="def record field anchored"><a href="#type-kernel.kern_funcs" class="anchor"></a><code><span>kern_funcs : <span><a href="#type-helper_func">helper_func</a> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Helper functions defined in kernel scope</p><span class="comment-delim">*)</span></div></li><li id="type-kernel.kern_native_fn" class="def record field anchored"><a href="#type-kernel.kern_native_fn" class="anchor"></a><code><span>kern_native_fn : <span><a href="#type-native_fn_t">native_fn_t</a> option</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Optional pre-compiled native function for CPU execution</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Kernel representation</p></div></div></div></body></html>
