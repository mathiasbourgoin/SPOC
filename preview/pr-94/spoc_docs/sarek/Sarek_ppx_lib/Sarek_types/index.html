<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sarek_types (sarek.Sarek_ppx_lib.Sarek_types)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">sarek</a> &#x00BB; <a href="../index.html">Sarek_ppx_lib</a> &#x00BB; Sarek_types</nav><header class="odoc-preamble"><h1>Module <code><span>Sarek_ppx_lib.Sarek_types</span></code></h1></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#type-constructors-and-constants">Type Constructors and Constants</a></li><li><a href="#type-predicates">Type Predicates</a></li><li><a href="#type-conversions">Type Conversions</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-prim_type"><a href="#type-prim_type" class="anchor"></a><code><span><span class="keyword">type</span> prim_type</span><span> = </span></code><ol><li id="type-prim_type.TUnit" class="def variant constructor anchored"><a href="#type-prim_type.TUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">TUnit</span></span></code></li><li id="type-prim_type.TBool" class="def variant constructor anchored"><a href="#type-prim_type.TBool" class="anchor"></a><code><span>| </span><span><span class="constructor">TBool</span></span></code></li><li id="type-prim_type.TInt32" class="def variant constructor anchored"><a href="#type-prim_type.TInt32" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt32</span></span></code></li></ol></div><div class="spec-doc"><p>Primitive types supported in GPU kernels (core language only). Numeric types like float32, float64, int64 are library-defined.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-registered_type"><a href="#type-registered_type" class="anchor"></a><code><span><span class="keyword">type</span> registered_type</span><span> = </span></code><ol><li id="type-registered_type.Int" class="def variant constructor anchored"><a href="#type-registered_type.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>OCaml int - alias for int32 on GPU</p><span class="comment-delim">*)</span></div></li><li id="type-registered_type.Int64" class="def variant constructor anchored"><a href="#type-registered_type.Int64" class="anchor"></a><code><span>| </span><span><span class="constructor">Int64</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit integer</p><span class="comment-delim">*)</span></div></li><li id="type-registered_type.Float32" class="def variant constructor anchored"><a href="#type-registered_type.Float32" class="anchor"></a><code><span>| </span><span><span class="constructor">Float32</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>32-bit float</p><span class="comment-delim">*)</span></div></li><li id="type-registered_type.Float64" class="def variant constructor anchored"><a href="#type-registered_type.Float64" class="anchor"></a><code><span>| </span><span><span class="constructor">Float64</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>64-bit float (double)</p><span class="comment-delim">*)</span></div></li><li id="type-registered_type.Char" class="def variant constructor anchored"><a href="#type-registered_type.Char" class="anchor"></a><code><span>| </span><span><span class="constructor">Char</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>8-bit character</p><span class="comment-delim">*)</span></div></li><li id="type-registered_type.Custom" class="def variant constructor anchored"><a href="#type-registered_type.Custom" class="anchor"></a><code><span>| </span><span><span class="constructor">Custom</span> <span class="keyword">of</span> string</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>User-registered types via <code>@@sarek.type</code></p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Registered type name - for library-defined types like float32, float64, int64. These are not built-in but are registered by libraries via <code>@@sarek.type</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-memspace"><a href="#type-memspace" class="anchor"></a><code><span><span class="keyword">type</span> memspace</span><span> = </span></code><ol><li id="type-memspace.Local" class="def variant constructor anchored"><a href="#type-memspace.Local" class="anchor"></a><code><span>| </span><span><span class="constructor">Local</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Thread-private memory</p><span class="comment-delim">*)</span></div></li><li id="type-memspace.Shared" class="def variant constructor anchored"><a href="#type-memspace.Shared" class="anchor"></a><code><span>| </span><span><span class="constructor">Shared</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Block-shared memory</p><span class="comment-delim">*)</span></div></li><li id="type-memspace.Global" class="def variant constructor anchored"><a href="#type-memspace.Global" class="anchor"></a><code><span>| </span><span><span class="constructor">Global</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Global device memory</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Memory spaces</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-typ"><a href="#type-typ" class="anchor"></a><code><span><span class="keyword">type</span> typ</span><span> = </span></code><ol><li id="type-typ.TPrim" class="def variant constructor anchored"><a href="#type-typ.TPrim" class="anchor"></a><code><span>| </span><span><span class="constructor">TPrim</span> <span class="keyword">of</span> <a href="#type-prim_type">prim_type</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Primitive types (core language)</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TReg" class="def variant constructor anchored"><a href="#type-typ.TReg" class="anchor"></a><code><span>| </span><span><span class="constructor">TReg</span> <span class="keyword">of</span> <a href="#type-registered_type">registered_type</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Registered types (library-defined: float32, float64, int64, etc.)</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TVar" class="def variant constructor anchored"><a href="#type-typ.TVar" class="anchor"></a><code><span>| </span><span><span class="constructor">TVar</span> <span class="keyword">of</span> <span><a href="#type-tvar">tvar</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Unification variable</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TVec" class="def variant constructor anchored"><a href="#type-typ.TVec" class="anchor"></a><code><span>| </span><span><span class="constructor">TVec</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Vector type (GPU array parameter)</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TArr" class="def variant constructor anchored"><a href="#type-typ.TArr" class="anchor"></a><code><span>| </span><span><span class="constructor">TArr</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <a href="#type-memspace">memspace</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Local array with memory space</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TFun" class="def variant constructor anchored"><a href="#type-typ.TFun" class="anchor"></a><code><span>| </span><span><span class="constructor">TFun</span> <span class="keyword">of</span> <span><a href="#type-typ">typ</a> list</span> * <a href="#type-typ">typ</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Function type</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TRecord" class="def variant constructor anchored"><a href="#type-typ.TRecord" class="anchor"></a><code><span>| </span><span><span class="constructor">TRecord</span> <span class="keyword">of</span> string * <span><span>(string * <a href="#type-typ">typ</a>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Record type: name, fields</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TVariant" class="def variant constructor anchored"><a href="#type-typ.TVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">TVariant</span> <span class="keyword">of</span> string * <span><span>(string * <span><a href="#type-typ">typ</a> option</span>)</span> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Variant type: name, constructors</p><span class="comment-delim">*)</span></div></li><li id="type-typ.TTuple" class="def variant constructor anchored"><a href="#type-typ.TTuple" class="anchor"></a><code><span>| </span><span><span class="constructor">TTuple</span> <span class="keyword">of</span> <span><a href="#type-typ">typ</a> list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Tuple type</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Types</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tvar"><a href="#type-tvar" class="anchor"></a><code><span><span class="keyword">and</span> tvar</span><span> = </span></code><ol><li id="type-tvar.Unbound" class="def variant constructor anchored"><a href="#type-tvar.Unbound" class="anchor"></a><code><span>| </span><span><span class="constructor">Unbound</span> <span class="keyword">of</span> int * int</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>id, level for generalization</p><span class="comment-delim">*)</span></div></li><li id="type-tvar.Link" class="def variant constructor anchored"><a href="#type-tvar.Link" class="anchor"></a><code><span>| </span><span><span class="constructor">Link</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Resolved to this type</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tvar_counter"><a href="#val-tvar_counter" class="anchor"></a><code><span><span class="keyword">val</span> tvar_counter : <span>int <span class="xref-unresolved">Stdlib</span>.Atomic.t</span></span></code></div><div class="spec-doc"><p>Generate fresh type variable IDs (thread-safe)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_tvar_id"><a href="#val-fresh_tvar_id" class="anchor"></a><code><span><span class="keyword">val</span> fresh_tvar_id : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fresh_tvar"><a href="#val-fresh_tvar" class="anchor"></a><code><span><span class="keyword">val</span> fresh_tvar : <span><span class="optlabel">?level</span>:int <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Create a fresh unbound type variable at given level</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reset_tvar_counter"><a href="#val-reset_tvar_counter" class="anchor"></a><code><span><span class="keyword">val</span> reset_tvar_counter : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Reset the type variable counter (for testing)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-repr"><a href="#val-repr" class="anchor"></a><code><span><span class="keyword">val</span> repr : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Follow links to get the actual type</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-occurs"><a href="#val-occurs" class="anchor"></a><code><span><span class="keyword">val</span> occurs : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if a type variable occurs in a type (for occurs check)</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-unify_error"><a href="#type-unify_error" class="anchor"></a><code><span><span class="keyword">type</span> unify_error</span><span> = </span></code><ol><li id="type-unify_error.Cannot_unify" class="def variant constructor anchored"><a href="#type-unify_error.Cannot_unify" class="anchor"></a><code><span>| </span><span><span class="constructor">Cannot_unify</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <a href="#type-typ">typ</a></span></code></li><li id="type-unify_error.Occurs_check" class="def variant constructor anchored"><a href="#type-unify_error.Occurs_check" class="anchor"></a><code><span>| </span><span><span class="constructor">Occurs_check</span> <span class="keyword">of</span> int * <a href="#type-typ">typ</a></span></code></li></ol></div><div class="spec-doc"><p>Unification error</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unify"><a href="#val-unify" class="anchor"></a><code><span><span class="keyword">val</span> unify : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(unit, <a href="#type-unify_error">unify_error</a>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p>Unify two types</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_prim"><a href="#val-pp_prim" class="anchor"></a><code><span><span class="keyword">val</span> pp_prim : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-prim_type">prim_type</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty printing</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_registered"><a href="#val-pp_registered" class="anchor"></a><code><span><span class="keyword">val</span> pp_registered : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-registered_type">registered_type</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_memspace"><a href="#val-pp_memspace" class="anchor"></a><code><span><span class="keyword">val</span> pp_memspace : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-memspace">memspace</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pp_typ"><a href="#val-pp_typ" class="anchor"></a><code><span><span class="keyword">val</span> pp_typ : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-typ_to_string"><a href="#val-typ_to_string" class="anchor"></a><code><span><span class="keyword">val</span> typ_to_string : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div></div><h2 id="type-constructors-and-constants"><a href="#type-constructors-and-constants" class="anchor"></a>Type Constructors and Constants</h2><p>Helper functions to construct common types.</p><div class="odoc-spec"><div class="spec value anchored" id="val-t_unit"><a href="#val-t_unit" class="anchor"></a><code><span><span class="keyword">val</span> t_unit : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Primitive type constructors</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_bool"><a href="#val-t_bool" class="anchor"></a><code><span><span class="keyword">val</span> t_bool : <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_int32"><a href="#val-t_int32" class="anchor"></a><code><span><span class="keyword">val</span> t_int32 : <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_vec"><a href="#val-t_vec" class="anchor"></a><code><span><span class="keyword">val</span> t_vec : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Composite type constructors</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_arr"><a href="#val-t_arr" class="anchor"></a><code><span><span class="keyword">val</span> t_arr : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-memspace">memspace</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_fun"><a href="#val-t_fun" class="anchor"></a><code><span><span class="keyword">val</span> t_fun : <span><span><a href="#type-typ">typ</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_float32"><a href="#val-t_float32" class="anchor"></a><code><span><span class="keyword">val</span> t_float32 : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Registered numeric types (library-defined).</p><p>These are not built-in primitives but use TReg for type-checking. They must be registered via <code>@@sarek.type</code> attributes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_float64"><a href="#val-t_float64" class="anchor"></a><code><span><span class="keyword">val</span> t_float64 : <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_int64"><a href="#val-t_int64" class="anchor"></a><code><span><span class="keyword">val</span> t_int64 : <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_int"><a href="#val-t_int" class="anchor"></a><code><span><span class="keyword">val</span> t_int : <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-t_char"><a href="#val-t_char" class="anchor"></a><code><span><span class="keyword">val</span> t_char : <a href="#type-typ">typ</a></span></code></div></div><h2 id="type-predicates"><a href="#type-predicates" class="anchor"></a>Type Predicates</h2><p>Boolean-returning functions to check type properties.</p><p>For Result-returning validators with error messages, see <code>Sarek_typer</code>:</p><ul><li><code>check_numeric</code>: Validates numeric types with location-aware errors</li><li><code>check_integer</code>: Validates integer types with location-aware errors</li><li><code>check_boolean</code>: Validates boolean types with location-aware errors</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-is_numeric"><a href="#val-is_numeric" class="anchor"></a><code><span><span class="keyword">val</span> is_numeric : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if type is numeric (includes both core int32 and registered float/int types).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_integer"><a href="#val-is_integer" class="anchor"></a><code><span><span class="keyword">val</span> is_integer : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if type is integer (core int32 or registered int64)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_float"><a href="#val-is_float" class="anchor"></a><code><span><span class="keyword">val</span> is_float : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if type is floating point (registered types)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_boolean"><a href="#val-is_boolean" class="anchor"></a><code><span><span class="keyword">val</span> is_boolean : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if type is boolean</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_tvar"><a href="#val-is_tvar" class="anchor"></a><code><span><span class="keyword">val</span> is_tvar : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if type is an unbound type variable</p></div></div><h2 id="type-conversions"><a href="#type-conversions" class="anchor"></a>Type Conversions</h2><p>Functions to convert between different type representations.</p><div class="odoc-spec"><div class="spec value anchored" id="val-type_of_type_expr"><a href="#val-type_of_type_expr" class="anchor"></a><code><span><span class="keyword">val</span> type_of_type_expr : <span><a href="../Sarek_ast/index.html#type-type_expr">Sarek_ast.type_expr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Convert AST type expression to type (with fresh type variables). Core types (unit, bool, int32) are handled directly. Other types (float32, float64, int64, etc.) are looked up in the type registry.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-memspace_of_ast"><a href="#val-memspace_of_ast" class="anchor"></a><code><span><span class="keyword">val</span> memspace_of_ast : <span><a href="../Sarek_ast/index.html#type-memspace">Sarek_ast.memspace</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-memspace">memspace</a></span></code></div><div class="spec-doc"><p>Convert memspace from AST to types</p></div></div></div></body></html>
