<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sarek_fusion (sarek.Sarek.Sarek_fusion)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">sarek</a> &#x00BB; <a href="../index.html">Sarek</a> &#x00BB; Sarek_fusion</nav><header class="odoc-preamble"><h1>Module <code><span>Sarek.Sarek_fusion</span></code></h1><p>Sarek_fusion - Kernel fusion on Sarek_ir</p><p>Implements vertical fusion: when kernel A writes to an intermediate array that kernel B reads, fuse them by inlining A's computation into B, eliminating the intermediate array.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#access-pattern-analysis">Access pattern analysis</a></li><li><a href="#expression-utilities">Expression utilities</a></li><li><a href="#statement-utilities">Statement utilities</a></li><li><a href="#analysis">Analysis</a></li><li><a href="#fusion">Fusion</a></li><li><a href="#high-level-interface">High-level interface</a></li><li><a href="#reduction-fusion">Reduction Fusion</a></li><li><a href="#stencil-fusion">Stencil Fusion</a></li><li><a href="#phase-5:-auto-fusion-heuristics">Phase 5: Auto-Fusion Heuristics</a></li></ul></nav></div><div class="odoc-content"><h2 id="access-pattern-analysis"><a href="#access-pattern-analysis" class="anchor"></a>Access pattern analysis</h2><div class="odoc-spec"><div class="spec type anchored" id="type-access_pattern"><a href="#type-access_pattern" class="anchor"></a><code><span><span class="keyword">type</span> access_pattern</span><span> = </span></code><ol><li id="type-access_pattern.OneToOne" class="def variant constructor anchored"><a href="#type-access_pattern.OneToOne" class="anchor"></a><code><span>| </span><span><span class="constructor">OneToOne</span> <span class="keyword">of</span> <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>arr<code>idx</code> where idx is thread-uniform</p><span class="comment-delim">*)</span></div></li><li id="type-access_pattern.Stencil" class="def variant constructor anchored"><a href="#type-access_pattern.Stencil" class="anchor"></a><code><span>| </span><span><span class="constructor">Stencil</span> <span class="keyword">of</span> <span>int list</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>arr<code>idx + offset</code> for each offset</p><span class="comment-delim">*)</span></div></li><li id="type-access_pattern.Reduction" class="def variant constructor anchored"><a href="#type-access_pattern.Reduction" class="anchor"></a><code><span>| </span><span><span class="constructor">Reduction</span> <span class="keyword">of</span> <a href="../../../spoc/Sarek_ir_types/index.html#type-binop">Sarek_ir_types.binop</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Reduction with associative op (Add, Mul, etc.)</p><span class="comment-delim">*)</span></div></li><li id="type-access_pattern.Gather" class="def variant constructor anchored"><a href="#type-access_pattern.Gather" class="anchor"></a><code><span>| </span><span><span class="constructor">Gather</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>arr<code>f(idx)</code> - arbitrary index</p><span class="comment-delim">*)</span></div></li><li id="type-access_pattern.Unknown" class="def variant constructor anchored"><a href="#type-access_pattern.Unknown" class="anchor"></a><code><span>| </span><span><span class="constructor">Unknown</span></span></code></li></ol></div><div class="spec-doc"><p>Access pattern for arrays</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-fusion_info"><a href="#type-fusion_info" class="anchor"></a><code><span><span class="keyword">type</span> fusion_info</span><span> = </span><span>{</span></code><ol><li id="type-fusion_info.reads" class="def record field anchored"><a href="#type-fusion_info.reads" class="anchor"></a><code><span>reads : <span><span>(string * <a href="#type-access_pattern">access_pattern</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>arrays read</p><span class="comment-delim">*)</span></div></li><li id="type-fusion_info.writes" class="def record field anchored"><a href="#type-fusion_info.writes" class="anchor"></a><code><span>writes : <span><span>(string * <a href="#type-access_pattern">access_pattern</a>)</span> list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>arrays written</p><span class="comment-delim">*)</span></div></li><li id="type-fusion_info.has_barriers" class="def record field anchored"><a href="#type-fusion_info.has_barriers" class="anchor"></a><code><span>has_barriers : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>contains barriers</p><span class="comment-delim">*)</span></div></li><li id="type-fusion_info.has_atomics" class="def record field anchored"><a href="#type-fusion_info.has_atomics" class="anchor"></a><code><span>has_atomics : bool;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>contains atomic ops</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Fusion analysis result for a kernel</p></div></div><h2 id="expression-utilities"><a href="#expression-utilities" class="anchor"></a>Expression utilities</h2><div class="odoc-spec"><div class="spec value anchored" id="val-expr_equal"><a href="#val-expr_equal" class="anchor"></a><code><span><span class="keyword">val</span> expr_equal : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if two expressions are structurally equal</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-expr_uses_array"><a href="#val-expr_uses_array" class="anchor"></a><code><span><span class="keyword">val</span> expr_uses_array : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if expression references an array</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subst_array_read"><a href="#val-subst_array_read" class="anchor"></a><code><span><span class="keyword">val</span> subst_array_read : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a></span></code></div><div class="spec-doc"><p>Substitute array reads in an expression</p></div></div><h2 id="statement-utilities"><a href="#statement-utilities" class="anchor"></a>Statement utilities</h2><div class="odoc-spec"><div class="spec value anchored" id="val-subst_array_read_stmt"><a href="#val-subst_array_read_stmt" class="anchor"></a><code><span><span class="keyword">val</span> subst_array_read_stmt : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a></span></code></div><div class="spec-doc"><p>Substitute array reads in a statement</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-stmt_uses_array"><a href="#val-stmt_uses_array" class="anchor"></a><code><span><span class="keyword">val</span> stmt_uses_array : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if statement uses an array</p></div></div><h2 id="analysis"><a href="#analysis" class="anchor"></a>Analysis</h2><div class="odoc-spec"><div class="spec value anchored" id="val-collect_reads_expr"><a href="#val-collect_reads_expr" class="anchor"></a><code><span><span class="keyword">val</span> collect_reads_expr : 
  <span><span><span>(string * <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string * <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a>)</span> list</span></span></code></div><div class="spec-doc"><p>Collect all array reads from an expression</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-collect_writes_stmt"><a href="#val-collect_writes_stmt" class="anchor"></a><code><span><span class="keyword">val</span> collect_writes_stmt : 
  <span><span><span>(string * <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string * <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a>)</span> list</span></span></code></div><div class="spec-doc"><p>Collect all array writes from a statement</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-collect_reads_stmt"><a href="#val-collect_reads_stmt" class="anchor"></a><code><span><span class="keyword">val</span> collect_reads_stmt : 
  <span><span><span>(string * <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string * <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a>)</span> list</span></span></code></div><div class="spec-doc"><p>Collect all array reads from a statement</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-has_barrier"><a href="#val-has_barrier" class="anchor"></a><code><span><span class="keyword">val</span> has_barrier : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if statement contains barriers</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-extract_offset"><a href="#val-extract_offset" class="anchor"></a><code><span><span class="keyword">val</span> extract_offset : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> * int)</span> option</span></span></code></div><div class="spec-doc"><p>Extract constant offset from index expression. Returns Some (base, offset) if idx = base + const or base - const.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_base_index"><a href="#val-is_base_index" class="anchor"></a><code><span><span class="keyword">val</span> is_base_index : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if index is a base expression (no offset)</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-analyze_pattern"><a href="#val-analyze_pattern" class="anchor"></a><code><span><span class="keyword">val</span> analyze_pattern : <span><span><span>(<span class="type-var">'a</span> * <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-access_pattern">access_pattern</a></span></code></div><div class="spec-doc"><p>Analyze access pattern for an array</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-analyze"><a href="#val-analyze" class="anchor"></a><code><span><span class="keyword">val</span> analyze : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-fusion_info">fusion_info</a></span></code></div><div class="spec-doc"><p>Analyze a kernel to extract fusion information.</p><p>Performs static analysis to determine:</p><ul><li>Which arrays are read and with what access patterns</li><li>Which arrays are written and with what access patterns</li><li>Whether barriers are present (prevents fusion)</li><li>Whether atomic operations are present (TODO: not yet detected)</li></ul><p>Access patterns determine fusability:</p><ul><li>OneToOne: Element-wise access (arr<code>tid</code>) - always fusable</li><li>Stencil: Neighbor access (arr<code>tid±k</code>) - fusable with care</li><li>Reduction: Associative reduction - special fusion rules</li><li>Gather: Irregular access (arr<code>f(tid)</code>) - generally not fusable</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">k</span> <p>Kernel to analyze</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>Fusion information record</p></li></ul></div></div><h2 id="fusion"><a href="#fusion" class="anchor"></a>Fusion</h2><div class="odoc-spec"><div class="spec value anchored" id="val-find_write_expr"><a href="#val-find_write_expr" class="anchor"></a><code><span><span class="keyword">val</span> find_write_expr : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> option</span></span></code></div><div class="spec-doc"><p>Find the expression written to arr<code>idx</code> in a statement. Returns None if not found or if multiple/conditional writes.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-can_fuse"><a href="#val-can_fuse" class="anchor"></a><code><span><span class="keyword">val</span> can_fuse : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if two kernels can be fused via an intermediate array.</p><p>Vertical fusion eliminates intermediate arrays by inlining the producer's computation into the consumer. Requirements:</p><p>1. Producer writes to intermediate with OneToOne pattern 2. Consumer reads from intermediate with OneToOne pattern 3. Both use same index expression (typically thread ID) 4. No barriers in either kernel (would break synchronization) 5. Intermediate not used elsewhere in consumer</p><p>Example fusable pattern:</p><pre class="language-ocaml"><code>  (* Producer: temp[tid] = a[tid] * 2 *)
  (* Consumer: b[tid] = temp[tid] + 1 *)
  (* Fused: b[tid] = (a[tid] * 2) + 1 *)</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">producer</span> <p>First kernel (writes to intermediate)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">consumer</span> <p>Second kernel (reads from intermediate)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">intermediate</span> <p>Name of array to eliminate</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>true if fusion is safe and beneficial</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fuse"><a href="#val-fuse" class="anchor"></a><code><span><span class="keyword">val</span> fuse : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a></span></code></div><div class="spec-doc"><p>Fuse producer into consumer, eliminating intermediate array.</p><p>Creates a new kernel that combines both computations: 1. Takes consumer's structure (parameters, signature) 2. Replaces reads of intermediate<code>idx</code> with producer's computation 3. Removes intermediate array from parameters 4. Preserves all other operations from both kernels</p><p>The transformation is safe because can_fuse verified:</p><ul><li>Same index expression used by both</li><li>No barriers (so no ordering requirements)</li><li>OneToOne access patterns (no data races)</li></ul><p>Example:</p><pre class="language-ocaml"><code>  (* Before: *)
  let prod = temp[tid] &lt;- a[tid] * 2 in
  let cons = b[tid] &lt;- temp[tid] + 1 in

  (* After fusion: *)
  let fused = b[tid] &lt;- (a[tid] * 2) + 1 in</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">producer</span> <p>First kernel (computation to inline)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">consumer</span> <p>Second kernel (receives inlined code)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">intermediate</span> <p>Array to eliminate</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>New fused kernel</p></li></ul></div></div><h2 id="high-level-interface"><a href="#high-level-interface" class="anchor"></a>High-level interface</h2><div class="odoc-spec"><div class="spec value anchored" id="val-fuse_pipeline"><a href="#val-fuse_pipeline" class="anchor"></a><code><span><span class="keyword">val</span> fuse_pipeline : 
  <span><span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> * <span>string list</span></span></code></div><div class="spec-doc"><p>Fuse a pipeline of kernels sequentially.</p><p>Attempts to fuse each consecutive kernel pair, eliminating intermediate arrays. Processes left-to-right, greedily fusing when possible.</p><p>Algorithm: 1. Start with first kernel as current 2. For each subsequent kernel:</p><ul><li>Find arrays that current writes and next reads (candidates)</li><li>If fusable, inline current into next and eliminate intermediate</li><li>Otherwise, advance to next kernel 3. Return final fused kernel and list of eliminated arrays</li></ul><p>Note: This is greedy and may not find optimal fusion. For example, fusing A→B might prevent better fusion of B→C. Use auto_fuse_pipeline for heuristic-based fusion that considers these tradeoffs.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kernels</span> <p>List of kernels to fuse (must be non-empty)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>(fused_kernel, eliminated_intermediates)</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Empty_pipeline</code> <p>if kernel list is empty</p></li></ul></div></div><h2 id="reduction-fusion"><a href="#reduction-fusion" class="anchor"></a>Reduction Fusion</h2><p>Fuses a map kernel with a subsequent reduction, eliminating the intermediate array. Pattern:</p><ul><li>Map: temp<code>i</code> = f(input<code>i</code>)</li><li>Reduce: result = fold(op, temp)</li><li>Fused: result = fold(op, f(input<code>i</code>))</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-detect_reduction_pattern"><a href="#val-detect_reduction_pattern" class="anchor"></a><code><span><span class="keyword">val</span> detect_reduction_pattern : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-stmt">Sarek_ir_types.stmt</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<a href="../../../spoc/Sarek_ir_types/index.html#type-var">Sarek_ir_types.var</a> * <a href="../../../spoc/Sarek_ir_types/index.html#type-binop">Sarek_ir_types.binop</a> * string * <a href="../../../spoc/Sarek_ir_types/index.html#type-var">Sarek_ir_types.var</a>)</span>
    option</span></span></code></div><div class="spec-doc"><p>Detect if a statement is a reduction pattern. Returns the accumulator variable, the reduction operator, the array being reduced, and the loop body.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_reduction_kernel"><a href="#val-is_reduction_kernel" class="anchor"></a><code><span><span class="keyword">val</span> is_reduction_kernel : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-binop">Sarek_ir_types.binop</a> option</span></span></code></div><div class="spec-doc"><p>Check if a kernel is a reduction over an array</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-can_fuse_reduction"><a href="#val-can_fuse_reduction" class="anchor"></a><code><span><span class="keyword">val</span> can_fuse_reduction : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Check if a map kernel can be fused with a reduction kernel.</p><p>Requirements: 1. Map writes to intermediate with OneToOne pattern 2. Reduction reads from intermediate in a reduction pattern 3. No barriers in either kernel</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fuse_reduction"><a href="#val-fuse_reduction" class="anchor"></a><code><span><span class="keyword">val</span> fuse_reduction : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a></span></code></div><div class="spec-doc"><p>Fuse a map kernel into a reduction kernel, eliminating intermediate array.</p><p>The resulting kernel: 1. Has reduction structure 2. Inlines map computation at each reduction step 3. Does not reference the intermediate array</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_fuse"><a href="#val-try_fuse" class="anchor"></a><code><span><span class="keyword">val</span> try_fuse : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> option</span></span></code></div><div class="spec-doc"><p>Try to fuse map+reduce, falling back to regular fusion if not applicable</p></div></div><h2 id="stencil-fusion"><a href="#stencil-fusion" class="anchor"></a>Stencil Fusion</h2><p>Fuses stencil operations with tiling. When producer uses stencil pattern and consumer also uses stencil, the combined radius determines halo size.</p><p>Example:</p><ul><li>Producer: temp<code>i</code> = (input<code>i-1</code> + input<code>i</code> + input<code>i+1</code>) / 3 (radius 1)</li><li>Consumer: out<code>i</code> = (temp<code>i-1</code> + temp<code>i</code> + temp<code>i+1</code>) / 3 (radius 1)</li><li>Fused: out<code>i</code> computed from input<code>i-2..i+2</code> (combined radius 2)</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-stencil_radius"><a href="#val-stencil_radius" class="anchor"></a><code><span><span class="keyword">val</span> stencil_radius : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Compute stencil radius from offset list</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_stencil_info"><a href="#val-get_stencil_info" class="anchor"></a><code><span><span class="keyword">val</span> get_stencil_info : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>int list</span> option</span></span></code></div><div class="spec-doc"><p>Get stencil info for array access in a kernel</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-can_fuse_stencil"><a href="#val-can_fuse_stencil" class="anchor"></a><code><span><span class="keyword">val</span> can_fuse_stencil : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p>Check if two stencil kernels can be fused.</p><p>Requirements: 1. Producer writes to intermediate 2. Consumer reads from intermediate with stencil pattern 3. No barriers in either kernel 4. Producer's output stencil is compatible</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-stencil_fusion_info"><a href="#type-stencil_fusion_info" class="anchor"></a><code><span><span class="keyword">type</span> stencil_fusion_info</span><span> = </span><span>{</span></code><ol><li id="type-stencil_fusion_info.combined_radius" class="def record field anchored"><a href="#type-stencil_fusion_info.combined_radius" class="anchor"></a><code><span>combined_radius : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Total radius after fusion</p><span class="comment-delim">*)</span></div></li><li id="type-stencil_fusion_info.producer_radius" class="def record field anchored"><a href="#type-stencil_fusion_info.producer_radius" class="anchor"></a><code><span>producer_radius : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Radius of producer's input stencil</p><span class="comment-delim">*)</span></div></li><li id="type-stencil_fusion_info.consumer_radius" class="def record field anchored"><a href="#type-stencil_fusion_info.consumer_radius" class="anchor"></a><code><span>consumer_radius : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Radius of consumer's intermediate stencil</p><span class="comment-delim">*)</span></div></li><li id="type-stencil_fusion_info.input_arrays" class="def record field anchored"><a href="#type-stencil_fusion_info.input_arrays" class="anchor"></a><code><span>input_arrays : <span>string list</span>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Arrays read by producer</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Information about fused stencil</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-analyze_stencil_fusion"><a href="#val-analyze_stencil_fusion" class="anchor"></a><code><span><span class="keyword">val</span> analyze_stencil_fusion : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-stencil_fusion_info">stencil_fusion_info</a> option</span></span></code></div><div class="spec-doc"><p>Analyze stencil fusion parameters</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subst_stencil_reads"><a href="#val-subst_stencil_reads" class="anchor"></a><code><span><span class="keyword">val</span> subst_stencil_reads : 
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span>int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a></span></code></div><div class="spec-doc"><p>Substitute all stencil reads of an array in an expression. For each read arr<code>base + offset</code>, substitute with the producer's computation shifted by that offset.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-shift_expr"><a href="#val-shift_expr" class="anchor"></a><code><span><span class="keyword">val</span> shift_expr : <span><a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../../../spoc/Sarek_ir_types/index.html#type-expr">Sarek_ir_types.expr</a></span></code></div><div class="spec-doc"><p>Shift all array indices in an expression by a constant offset</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fuse_stencil"><a href="#val-fuse_stencil" class="anchor"></a><code><span><span class="keyword">val</span> fuse_stencil : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a></span></code></div><div class="spec-doc"><p>Fuse stencil kernels, substituting intermediate reads with producer computation</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_fuse_all"><a href="#val-try_fuse_all" class="anchor"></a><code><span><span class="keyword">val</span> try_fuse_all : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> option</span></span></code></div><div class="spec-doc"><p>Enhanced try_fuse that includes stencil fusion</p></div></div><h2 id="phase-5:-auto-fusion-heuristics"><a href="#phase-5:-auto-fusion-heuristics" class="anchor"></a>Phase 5: Auto-Fusion Heuristics</h2><p>Simple pattern-based heuristics for deciding when fusion is beneficial. Conservative - never recommends fusion when it would hurt.</p><div class="odoc-spec"><div class="spec type anchored" id="type-fusion_decision"><a href="#type-fusion_decision" class="anchor"></a><code><span><span class="keyword">type</span> fusion_decision</span><span> = </span></code><ol><li id="type-fusion_decision.Fuse" class="def variant constructor anchored"><a href="#type-fusion_decision.Fuse" class="anchor"></a><code><span>| </span><span><span class="constructor">Fuse</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Definitely fuse</p><span class="comment-delim">*)</span></div></li><li id="type-fusion_decision.DontFuse" class="def variant constructor anchored"><a href="#type-fusion_decision.DontFuse" class="anchor"></a><code><span>| </span><span><span class="constructor">DontFuse</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Definitely don't fuse</p><span class="comment-delim">*)</span></div></li><li id="type-fusion_decision.MaybeFuse" class="def variant constructor anchored"><a href="#type-fusion_decision.MaybeFuse" class="anchor"></a><code><span>| </span><span><span class="constructor">MaybeFuse</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>User should decide / profile</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Fusion decision</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-fusion_hint"><a href="#type-fusion_hint" class="anchor"></a><code><span><span class="keyword">type</span> fusion_hint</span><span> = </span><span>{</span></code><ol><li id="type-fusion_hint.decision" class="def record field anchored"><a href="#type-fusion_hint.decision" class="anchor"></a><code><span>decision : <a href="#type-fusion_decision">fusion_decision</a>;</span></code></li><li id="type-fusion_hint.reason" class="def record field anchored"><a href="#type-fusion_hint.reason" class="anchor"></a><code><span>reason : string;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Fusion hint with decision and reason</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-should_fuse"><a href="#val-should_fuse" class="anchor"></a><code><span><span class="keyword">val</span> should_fuse : 
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-fusion_hint">fusion_hint</a></span></code></div><div class="spec-doc"><p>Heuristic: decide if fusion should be applied.</p><p>Not all legal fusions are beneficial. This function applies heuristics to decide when fusion improves performance:</p><p>**Fuse (always beneficial):**</p><ul><li>Element-wise producer → element-wise consumer (eliminates memory)</li><li>Map → Reduction (eliminates temporary, enables tree reduction)</li></ul><p>**Don't fuse (likely harmful):**</p><ul><li>Any kernel with barriers (breaks synchronization semantics)</li><li>Producer → Gather consumer (unpredictable memory access)</li><li>Large stencil radius (&gt;3 neighbors, shared memory better)</li></ul><p>**Maybe fuse (profile to decide):**</p><ul><li>Small stencil (≤3 neighbors, computation cost vs memory)</li><li>Unknown patterns (conservative - don't auto-fuse)</li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">producer</span> <p>First kernel</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">consumer</span> <p>Second kernel</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">intermediate</span> <p>Array between them</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>Decision (Fuse/DontFuse/MaybeFuse) with human-readable reason</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-auto_fuse_pipeline"><a href="#val-auto_fuse_pipeline" class="anchor"></a><code><span><span class="keyword">val</span> auto_fuse_pipeline : 
  <span><span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> * <span>string list</span> * <span>string list</span></span></code></div><div class="spec-doc"><p>Auto-fuse a pipeline using heuristics.</p><p>Similar to fuse_pipeline, but uses should_fuse heuristics to decide which fusions to apply. This prevents harmful fusions while still eliminating obvious intermediates.</p><p>Decision process for each candidate fusion:</p><ul><li>**Fuse**: Apply fusion, eliminate intermediate</li><li>**DontFuse**: Skip this pair, keep intermediate</li><li>**MaybeFuse**: Conservative - skip (user can manually fuse if profiling shows benefit)</li></ul><p>This is the recommended entry point for automatic optimization. Manual fusion (via fuse_pipeline) is available for expert users who have profiled specific fusion decisions.</p><p>Example usage:</p><pre class="language-ocaml"><code>  (* Define pipeline *)
  let kernels = [map_kernel; filter_kernel; reduce_kernel] in

  (* Auto-fuse with heuristics *)
  let fused, eliminated, skipped =
    Sarek_fusion.auto_fuse_pipeline kernels
  in

  (* Execute fused kernel (1 launch instead of 3) *)
  Execute.run_vectors ~device ~ir:fused ~args ~block ~grid ()</code></pre><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kernels</span> <p>Pipeline to optimize (must be non-empty)</p></li></ul><ul class="at-tags"><li class="returns"><span class="at-tag">returns</span> <p>(fused_kernel, eliminated_arrays, skipped_reasons)</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Empty_pipeline</code> <p>if kernel list is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-analyze_pipeline"><a href="#val-analyze_pipeline" class="anchor"></a><code><span><span class="keyword">val</span> analyze_pipeline : <span><span><a href="../../../spoc/Sarek_ir_types/index.html#type-kernel">Sarek_ir_types.kernel</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print fusion analysis for a pipeline.</p><p>Diagnostic function that analyzes each consecutive kernel pair and prints detailed information about fusability:</p><ul><li>Access patterns (OneToOne, Stencil, Reduction, etc.)</li><li>Candidate intermediate arrays</li><li>Fusion decision and reasoning</li><li>Potential benefits or risks</li></ul><p>Useful for understanding why auto_fuse_pipeline made specific decisions or for identifying manual fusion opportunities.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kernels</span> <p>Pipeline to analyze</p></li></ul></div></div></div></body></html>
