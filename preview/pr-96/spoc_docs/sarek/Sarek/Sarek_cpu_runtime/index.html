<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Sarek_cpu_runtime (sarek.Sarek.Sarek_cpu_runtime)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 3.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">Index</a> &#x00BB; <a href="../../index.html">sarek</a> &#x00BB; <a href="../index.html">Sarek</a> &#x00BB; Sarek_cpu_runtime</nav><header class="odoc-preamble"><h1>Module <code><span>Sarek.Sarek_cpu_runtime</span></code></h1><p>Sarek_cpu_runtime - CPU runtime for generated native kernels</p><p>This module provides the runtime support for kernels compiled to native OCaml code by the Sarek PPX. Unlike Sarek_interp which interprets the AST, this module is used by generated code that runs at full native speed.</p></header><div class="odoc-tocs"><nav class="odoc-toc odoc-local-toc"><ul><li><a href="#execution-mode">Execution Mode</a></li><li><a href="#thread-state">Thread State</a></li><li><a href="#global-index-helpers">Global Index Helpers</a></li><li><a href="#shared-memory">Shared Memory</a><ul><li><a href="#typed-allocators">Typed Allocators</a></li></ul></li><li><a href="#execution-modes">Execution Modes</a></li><li><a href="#fission-mode---thread-pool-execution">Fission Mode - Thread Pool Execution</a><ul><li><a href="#asynchronous-queue-api">Asynchronous Queue API</a></li></ul></li><li><a href="#optimized-simple-kernel-runners">Optimized Simple Kernel Runners</a></li></ul></nav></div><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-Float32"><a href="#module-Float32" class="anchor"></a><code><span><span class="keyword">module</span> Float32</span><span> = <a href="../Sarek_float32/index.html">Sarek_float32</a></span></code></div></div><h2 id="execution-mode"><a href="#execution-mode" class="anchor"></a>Execution Mode</h2><div class="odoc-spec"><div class="spec type anchored" id="type-exec_mode"><a href="#type-exec_mode" class="anchor"></a><code><span><span class="keyword">type</span> exec_mode</span><span> = </span></code><ol><li id="type-exec_mode.Sequential" class="def variant constructor anchored"><a href="#type-exec_mode.Sequential" class="anchor"></a><code><span>| </span><span><span class="constructor">Sequential</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Single-threaded, barriers are no-ops</p><span class="comment-delim">*)</span></div></li><li id="type-exec_mode.Parallel" class="def variant constructor anchored"><a href="#type-exec_mode.Parallel" class="anchor"></a><code><span>| </span><span><span class="constructor">Parallel</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Spawn domains per kernel launch</p><span class="comment-delim">*)</span></div></li><li id="type-exec_mode.Threadpool" class="def variant constructor anchored"><a href="#type-exec_mode.Threadpool" class="anchor"></a><code><span>| </span><span><span class="constructor">Threadpool</span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Use persistent thread pool (fission mode)</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Execution mode for native kernels</p></div></div><h2 id="thread-state"><a href="#thread-state" class="anchor"></a>Thread State</h2><div class="odoc-spec"><div class="spec type anchored" id="type-thread_state"><a href="#type-thread_state" class="anchor"></a><code><span><span class="keyword">type</span> thread_state</span><span> = </span><span>{</span></code><ol><li id="type-thread_state.thread_idx_x" class="def record field anchored"><a href="#type-thread_state.thread_idx_x" class="anchor"></a><code><span>thread_idx_x : int32;</span></code></li><li id="type-thread_state.thread_idx_y" class="def record field anchored"><a href="#type-thread_state.thread_idx_y" class="anchor"></a><code><span>thread_idx_y : int32;</span></code></li><li id="type-thread_state.thread_idx_z" class="def record field anchored"><a href="#type-thread_state.thread_idx_z" class="anchor"></a><code><span>thread_idx_z : int32;</span></code></li><li id="type-thread_state.block_idx_x" class="def record field anchored"><a href="#type-thread_state.block_idx_x" class="anchor"></a><code><span>block_idx_x : int32;</span></code></li><li id="type-thread_state.block_idx_y" class="def record field anchored"><a href="#type-thread_state.block_idx_y" class="anchor"></a><code><span>block_idx_y : int32;</span></code></li><li id="type-thread_state.block_idx_z" class="def record field anchored"><a href="#type-thread_state.block_idx_z" class="anchor"></a><code><span>block_idx_z : int32;</span></code></li><li id="type-thread_state.block_dim_x" class="def record field anchored"><a href="#type-thread_state.block_dim_x" class="anchor"></a><code><span>block_dim_x : int32;</span></code></li><li id="type-thread_state.block_dim_y" class="def record field anchored"><a href="#type-thread_state.block_dim_y" class="anchor"></a><code><span>block_dim_y : int32;</span></code></li><li id="type-thread_state.block_dim_z" class="def record field anchored"><a href="#type-thread_state.block_dim_z" class="anchor"></a><code><span>block_dim_z : int32;</span></code></li><li id="type-thread_state.grid_dim_x" class="def record field anchored"><a href="#type-thread_state.grid_dim_x" class="anchor"></a><code><span>grid_dim_x : int32;</span></code></li><li id="type-thread_state.grid_dim_y" class="def record field anchored"><a href="#type-thread_state.grid_dim_y" class="anchor"></a><code><span>grid_dim_y : int32;</span></code></li><li id="type-thread_state.grid_dim_z" class="def record field anchored"><a href="#type-thread_state.grid_dim_z" class="anchor"></a><code><span>grid_dim_z : int32;</span></code></li><li id="type-thread_state.barrier" class="def record field anchored"><a href="#type-thread_state.barrier" class="anchor"></a><code><span>barrier : <span>unit <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Thread state passed to each kernel invocation. Contains thread/block/grid indices and dimensions, plus a barrier function.</p><p>All indices are int32 to match GPU semantics (Sarek_stdlib.Gpu uses int32).</p></div></div><h2 id="global-index-helpers"><a href="#global-index-helpers" class="anchor"></a>Global Index Helpers</h2><div class="odoc-spec"><div class="spec value anchored" id="val-global_idx_x"><a href="#val-global_idx_x" class="anchor"></a><code><span><span class="keyword">val</span> global_idx_x : <span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-global_idx_y"><a href="#val-global_idx_y" class="anchor"></a><code><span><span class="keyword">val</span> global_idx_y : <span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-global_idx_z"><a href="#val-global_idx_z" class="anchor"></a><code><span><span class="keyword">val</span> global_idx_z : <span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-global_size_x"><a href="#val-global_size_x" class="anchor"></a><code><span><span class="keyword">val</span> global_size_x : <span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-global_size_y"><a href="#val-global_size_y" class="anchor"></a><code><span><span class="keyword">val</span> global_size_y : <span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-global_size_z"><a href="#val-global_size_z" class="anchor"></a><code><span><span class="keyword">val</span> global_size_z : <span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> int32</span></code></div></div><h2 id="shared-memory"><a href="#shared-memory" class="anchor"></a>Shared Memory</h2><div class="odoc-spec"><div class="spec type anchored" id="type-shared_mem"><a href="#type-shared_mem" class="anchor"></a><code><span><span class="keyword">type</span> shared_mem</span></code></div><div class="spec-doc"><p>Shared memory container for a block. Uses per-type hashtables for type safety on common types.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create_shared"><a href="#val-create_shared" class="anchor"></a><code><span><span class="keyword">val</span> create_shared : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-shared_mem">shared_mem</a></span></code></div><div class="spec-doc"><p>Create a new empty shared memory container.</p></div></div><h3 id="typed-allocators"><a href="#typed-allocators" class="anchor"></a>Typed Allocators</h3><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_shared_int"><a href="#val-alloc_shared_int" class="anchor"></a><code><span><span class="keyword">val</span> alloc_shared_int : <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int array</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_shared_float"><a href="#val-alloc_shared_float" class="anchor"></a><code><span><span class="keyword">val</span> alloc_shared_float : <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span>float array</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_shared_int32"><a href="#val-alloc_shared_int32" class="anchor"></a><code><span><span class="keyword">val</span> alloc_shared_int32 : <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> <span>int32 array</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_shared_int64"><a href="#val-alloc_shared_int64" class="anchor"></a><code><span><span class="keyword">val</span> alloc_shared_int64 : <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> <span>int64 array</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-alloc_shared"><a href="#val-alloc_shared" class="anchor"></a><code><span><span class="keyword">val</span> alloc_shared : <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> array</span></span></code></div><div class="spec-doc"><p>Generic Allocator</p><p>For custom types not covered by typed allocators. Uses Obj.t internally.</p></div></div><h2 id="execution-modes"><a href="#execution-modes" class="anchor"></a>Execution Modes</h2><div class="odoc-spec"><div class="spec value anchored" id="val-run_sequential"><a href="#val-run_sequential" class="anchor"></a><code><span><span class="keyword">val</span> run_sequential : 
  <span><span class="label">block</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">grid</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Run kernel sequentially. All threads execute in order, barriers are no-ops. Good for debugging and correctness testing. The kernel function receives thread_state, shared_mem (for the block), and args.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run_parallel"><a href="#val-run_parallel" class="anchor"></a><code><span><span class="keyword">val</span> run_parallel : 
  <span><span class="label">block</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">grid</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Run kernel in parallel. Threads within each block run in parallel using OCaml 5 Domains. Barriers properly synchronize all threads within a block using Mutex/Condition. Blocks run sequentially.</p></div></div><h2 id="fission-mode---thread-pool-execution"><a href="#fission-mode---thread-pool-execution" class="anchor"></a>Fission Mode - Thread Pool Execution</h2><p>For the fission device, kernels are executed by a persistent thread pool. This eliminates per-launch Domain spawn/join overhead for workloads with many consecutive kernel launches (like odd-even sort with 512 launches).</p><p>Architecture:</p><ul><li>A persistent pool of N worker domains (one per core) stays alive</li><li>Each kernel launch distributes work to workers via condition variables</li><li>Workers execute their portion and signal completion</li><li>No Domain spawn/join per kernel - just signaling overhead</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-run_threadpool"><a href="#val-run_threadpool" class="anchor"></a><code><span><span class="keyword">val</span> run_threadpool : 
  <span><span class="label">has_barriers</span>:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">block</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">grid</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="#type-thread_state">thread_state</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-shared_mem">shared_mem</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Run kernel using the persistent thread pool. Like run_parallel but uses pre-created worker domains. Best for workloads with many consecutive kernel launches.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">has_barriers</span> <p>Compile-time flag from PPX indicating barrier usage.</p><ul><li>false: use thread distribution (faster, more granular)</li><li>true: use block distribution with BSP barriers</li></ul></li></ul></div></div><h3 id="asynchronous-queue-api"><a href="#asynchronous-queue-api" class="anchor"></a>Asynchronous Queue API</h3><p>Multiple queues are supported (like CUDA/OpenCL command queues):</p><ul><li>Same queue_id: kernels execute in order (serialized)</li><li>Different queue_id: kernels can run in parallel (one dispatcher per queue)</li></ul><div class="odoc-spec"><div class="spec value anchored" id="val-enqueue_fission"><a href="#val-enqueue_fission" class="anchor"></a><code><span><span class="keyword">val</span> enqueue_fission : 
  <span><span class="optlabel">?queue_id</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">kernel</span>:
    <span>(<span><span class="label">mode</span>:<a href="#type-exec_mode">exec_mode</a> <span class="arrow">&#45;&gt;</span></span>
      <span><span class="label">block</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
      <span><span class="label">grid</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
      <span><span><a href="../../../spoc/Spoc_framework/Framework_sig/index.html#type-exec_arg">Spoc_framework.Framework_sig.exec_arg</a> array</span> <span class="arrow">&#45;&gt;</span></span>
      unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">args</span>:<span><a href="../../../spoc/Spoc_framework/Framework_sig/index.html#type-exec_arg">Spoc_framework.Framework_sig.exec_arg</a> array</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">block</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">grid</span>:<span>(int * int * int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span>unit <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Enqueue a kernel for fission execution on a specific queue. The kernel starts executing immediately in the background via thread pool. Kernels on the same queue execute in order; different queues run in parallel. Default queue_id is 0.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush_fission_queue"><a href="#val-flush_fission_queue" class="anchor"></a><code><span><span class="keyword">val</span> flush_fission_queue : <span>int <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Wait for a specific queue to complete.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-flush_fission"><a href="#val-flush_fission" class="anchor"></a><code><span><span class="keyword">val</span> flush_fission : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Wait for all fission queues to complete. Called by Devices.flush.</p></div></div><h2 id="optimized-simple-kernel-runners"><a href="#optimized-simple-kernel-runners" class="anchor"></a>Optimized Simple Kernel Runners</h2><p>For kernels that only use global_idx_x/y/z without thread/block dimensions, shared memory, or barriers, we can skip the expensive thread_state machinery and just pass the global index directly.</p><p>This eliminates:</p><ul><li>6 Obj.set_field calls per element</li><li>6 integer divisions/modulos</li><li>Function call overhead through thread_state</li></ul><p>These functions are used when the PPX detects Simple1D/2D/3D execution strategy.</p><div class="odoc-spec"><div class="spec value anchored" id="val-run_1d_threadpool"><a href="#val-run_1d_threadpool" class="anchor"></a><code><span><span class="keyword">val</span> run_1d_threadpool : <span><span class="label">total_x</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>int32 <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Run a simple 1D kernel in parallel - just iterates over global_idx_x.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">total_x</span> <p>Total number of elements (block_x * grid_x)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kernel</span> <p>Function taking (gid_x, args)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run_2d_threadpool"><a href="#val-run_2d_threadpool" class="anchor"></a><code><span><span class="keyword">val</span> run_2d_threadpool : 
  <span><span class="label">width</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">height</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int32 <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Run a simple 2D kernel in parallel - iterates over global_idx_x, global_idx_y.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">width</span> <p>Total width (block_x * grid_x)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">height</span> <p>Total height (block_y * grid_y)</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kernel</span> <p>Function taking (gid_x, gid_y, args)</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-run_3d_threadpool"><a href="#val-run_3d_threadpool" class="anchor"></a><code><span><span class="keyword">val</span> run_3d_threadpool : 
  <span><span class="label">width</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">height</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span>int32 <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> <span>int32 <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Run a simple 3D kernel in parallel - iterates over global_idx_x/y/z.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">width</span> <p>Total width</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">height</span> <p>Total height</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">depth</span> <p>Total depth</p></li></ul><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">kernel</span> <p>Function taking (gid_x, gid_y, gid_z, args)</p></li></ul></div></div></div></body></html>
